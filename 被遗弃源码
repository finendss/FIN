local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Window = WindUI:CreateWindow({
    Folder = "Ringta 脚本",
    Title = "RINGTA 脚本",
    Icon = "star",
    Author = "RINGTA 和 BUBLIK6241",
    Theme = "暗黑",
    Size = UDim2.fromOffset(500, 420),
    HasOutline = true,
})

Window:EditOpenButton({
    Title = "打开脚本",
    Icon = "monitor",
    CornerRadius = UDim.new(0, 6),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromRGB(30, 30, 30), Color3.fromRGB(255, 255, 255)),
    Draggable = true,
})

local Tabs = {
    Stamina_Settings = Window:Tab({ Title = "耐力设置", Icon = "footprints" }),
    Esp = Window:Tab({ Title = "透视", Icon = "eye" }),
    AutoBlock = Window:Tab({ Title = "自动格挡", Icon = "shield" }),
    Misc = Window:Tab({ Title = "杂项", Icon = "gift" }),
    Auto_Stun = Window:Tab({ Title = "自动眩晕", Icon = "spline-pointer" }),
    Random = Window:Tab({ Title = "随机", Icon = "crosshair" }),
    Hitbox_expander = Window:Tab({ Title = "攻击范围扩大", Icon = "target" }),
    Generator = Window:Tab({ Title = "发电机", Icon = "battery-charging" }),
    Teleport = Window:Tab({Title = "传送", Icon = "cable" }),
    Credits = Window:Tab({ Title = "致谢", Icon = "award" })
}

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local sprintModule = require(game.ReplicatedStorage.Systems.Character.Game.Sprinting)

-- 保存默认值
local defaultMaxStamina = sprintModule.MaxStamina
local defaultSprintSpeed = sprintModule.SprintSpeed
local defaultStaminaGain = sprintModule.StaminaGain
local defaultStaminaDrain = sprintModule.StaminaDrain or 1
local defaultRegenDelay = sprintModule.StaminaRegenDelay or 0.5

-- 当前值
local maxStaminaValue = sprintModule.MaxStamina
local sprintSpeedValue = sprintModule.SprintSpeed
local staminaGainValue = sprintModule.StaminaGain
local staminaDrainValue = sprintModule.StaminaDrain or 1
local regenDelayValue = sprintModule.StaminaRegenDelay or 0.5

-- 无限耐力
local infinityStaminaActive = false
local staminaThread = nil

local function EnableInfinityStamina()
    infinityStaminaActive = true
    staminaThread = task.spawn(function()
        while infinityStaminaActive do
            task.wait(0.005)
            sprintModule.MaxStamina = maxStaminaValue
            sprintModule.SprintSpeed = sprintSpeedValue
            sprintModule.StaminaGain = staminaGainValue
            sprintModule.StaminaDrain = staminaDrainValue
            sprintModule.StaminaRegenDelay = regenDelayValue
            sprintModule.Stamina = sprintModule.MaxStamina
        end
    end)
end

local function DisableInfinityStamina()
    infinityStaminaActive = false
    if staminaThread then
        task.cancel(staminaThread)
        staminaThread = nil
    end
end

local function ResetStaminaSettings()
    maxStaminaValue = defaultMaxStamina
    sprintSpeedValue = defaultSprintSpeed
    staminaGainValue = defaultStaminaGain
    staminaDrainValue = defaultStaminaDrain
    regenDelayValue = defaultRegenDelay

    sprintModule.MaxStamina = maxStaminaValue
    sprintModule.SprintSpeed = sprintSpeedValue
    sprintModule.StaminaGain = staminaGainValue
    sprintModule.StaminaDrain = staminaDrainValue
    sprintModule.StaminaRegenDelay = regenDelayValue
end

-- GUI
Tabs.Stamina_Settings:Toggle({
    Title = "无限耐力",
    Default = false,
    Callback = function(state)
        if state then
            EnableInfinityStamina()
        else
            DisableInfinityStamina()
        end
    end
})

Tabs.Stamina_Settings:Slider({
    Title = "最大耐力",
    Step = 1,
    Value = {Min = 1, Max = 500, Default = maxStaminaValue},
    Suffix = " 最大",
    Callback = function(val)
        maxStaminaValue = tonumber(val) or defaultMaxStamina
        sprintModule.MaxStamina = maxStaminaValue
        if not infinityStaminaActive and sprintModule.Stamina > maxStaminaValue then
            sprintModule.Stamina = maxStaminaValue
        end
    end
})

Tabs.Stamina_Settings:Slider({
    Title = "冲刺速度",
    Step = 1,
    Value = {Min = 1, Max = 40, Default = sprintSpeedValue},
    Suffix = " 速度",
    Callback = function(val)
        sprintSpeedValue = tonumber(val) or defaultSprintSpeed
        sprintModule.SprintSpeed = sprintSpeedValue
    end
})

Tabs.Stamina_Settings:Slider({
    Title = "耐力恢复",
    Step = 1,
    Value = {Min = 1, Max = 500, Default = staminaGainValue},
    Suffix = " 每秒",
    Callback = function(val)
        staminaGainValue = tonumber(val) or defaultStaminaGain
        sprintModule.StaminaGain = staminaGainValue
    end
})

Tabs.Stamina_Settings:Slider({
    Title = "耐力消耗",
    Step = 1,
    Value = {Min = 0, Max = 100, Default = staminaDrainValue},
    Suffix = " 每秒",
    Callback = function(val)
        staminaDrainValue = tonumber(val) or defaultStaminaDrain
        sprintModule.StaminaDrain = staminaDrainValue
    end
})

Tabs.Stamina_Settings:Slider({
    Title = "恢复延迟",
    Step = 0.1,
    Value = {Min = 0, Max = 5, Default = regenDelayValue},
    Suffix = " 秒",
    Callback = function(val)
        regenDelayValue = tonumber(val) or defaultRegenDelay
        sprintModule.StaminaRegenDelay = regenDelayValue
    end
})

Tabs.Stamina_Settings:Button({
    Title = "重置为默认",
    Callback = function()
        ResetStaminaSettings()
    end
})

local espKillerActive = false
local killerHighlights = {}
local killerEspThread

local function clearKillerHighlights()
    for _, h in ipairs(killerHighlights) do
        if h and h.Parent then h:Destroy() end
    end
    killerHighlights = {}
end

local function createKillerHighlight(model)
    local highlight = Instance.new("Highlight")
    highlight.Adornee = model
    highlight.FillColor = Color3.fromRGB(255, 0, 0)
    highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = model
    table.insert(killerHighlights, highlight)
end

local function updateKillerESP()
    clearKillerHighlights()
    local killersFolder = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
            createKillerHighlight(killer)
        end
    end
end

Tabs.Esp:Toggle({
    Title = "杀手透视",
    Default = false,
    Callback = function(state)
        espKillerActive = state
        if espKillerActive then
            killerEspThread = task.spawn(function()
                while espKillerActive do
                    updateKillerESP()
                    task.wait(5)
                end
            end)
        else
            if killerEspThread then task.cancel(killerEspThread); killerEspThread = nil end
            clearKillerHighlights()
        end
    end
})

local espSurvivorActive = false
local survivorHighlights = {}
local survivorEspThread

local function clearSurvivorHighlights()
    for _, h in ipairs(survivorHighlights) do
        if h and h.Parent then h:Destroy() end
    end
    survivorHighlights = {}
end

local function createSurvivorHighlight(model)
    local highlight = Instance.new("Highlight")
    highlight.Adornee = model
    highlight.FillColor = Color3.fromRGB(0, 255, 0)
    highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = model
    table.insert(survivorHighlights, highlight)
end

local function updateSurvivorESP()
    clearSurvivorHighlights()
    local survivorsFolder = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Survivors")
    if not survivorsFolder then return end
    for _, survivor in ipairs(survivorsFolder:GetChildren()) do
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
            createSurvivorHighlight(survivor)
        end
    end
end

Tabs.Esp:Toggle({
    Title = "幸存者透视",
    Default = false,
    Callback = function(state)
        espSurvivorActive = state
        if espSurvivorActive then
            survivorEspThread = task.spawn(function()
                while espSurvivorActive do
                    updateSurvivorESP()
                    task.wait(5)
                end
            end)
        else
            if survivorEspThread then task.cancel(survivorEspThread); survivorEspThread = nil end
            clearSurvivorHighlights()
        end
    end
})

-- 物品透视
-- // 设置
local espEnabledMedkit = false
local espEnabledBloxy = false

-- // 清理函数
local function clearESP(name)
    for _, item in ipairs(workspace:GetDescendants()) do
        if item.Name == name and (item:IsA("BasePart") or item:IsA("Model")) then
            local part = item:IsA("BasePart") and item or item:FindFirstChildWhichIsA("BasePart")
            if part and part:FindFirstChild("ItemHighlight") then
                part.ItemHighlight:Destroy()
            end
        end
    end
end

-- // 主要ESP更新器
local function updateESP()
    for _, item in ipairs(workspace:GetDescendants()) do
        local part = nil
        if item:IsA("BasePart") then
            part = item
        elseif item:IsA("Model") then
            part = item:FindFirstChildWhichIsA("BasePart")
        end

        if part then
            if item.Name == "Medkit" and espEnabledMedkit and not part:FindFirstChild("ItemHighlight") then
                local highlight = Instance.new("Highlight")
                highlight.Name = "ItemHighlight"
                highlight.FillColor = Color3.fromRGB(255, 105, 180) -- 粉色
                highlight.OutlineColor = Color3.fromRGB(255, 105, 180)
                highlight.FillTransparency = 0.5
                highlight.OutlineTransparency = 0
                highlight.Adornee = part:IsA("Model") and item or part
                highlight.Parent = part
            elseif item.Name == "BloxyCola" and espEnabledBloxy and not part:FindFirstChild("ItemHighlight") then
                local highlight = Instance.new("Highlight")
                highlight.Name = "ItemHighlight"
                highlight.FillColor = Color3.fromRGB(0, 150, 255) -- 蓝色
                highlight.OutlineColor = Color3.fromRGB(0, 150, 255)
                highlight.FillTransparency = 0.5
                highlight.OutlineTransparency = 0
                highlight.Adornee = part:IsA("Model") and item or part
                highlight.Parent = part
            end
        end
    end
end

-- // 线程
local medkitEspThread = nil
local bloxyEspThread = nil

-- // 通过WindUI创建Toggles
Tabs.Esp:Toggle({
    Title = "医疗包透视",
    Default = false,
    Callback = function(state)
        espEnabledMedkit = state
        if espEnabledMedkit then
            medkitEspThread = task.spawn(function()
                while espEnabledMedkit do
                    updateESP()
                    task.wait(2)
                end
            end)
        else
            if medkitEspThread then
                task.cancel(medkitEspThread)
                medkitEspThread = nil
            end
            clearESP("Medkit")
        end
    end
})

Tabs.Esp:Toggle({
    Title = "Bloxy可乐透视",
    Default = false,
    Callback = function(state)
        espEnabledBloxy = state
        if espEnabledBloxy then
            bloxyEspThread = task.spawn(function()
                while espEnabledBloxy do
                    updateESP()
                    task.wait(2)
                end
            end)
        else
            if bloxyEspThread then
                task.cancel(bloxyEspThread)
                bloxyEspThread = nil
            end
            clearESP("BloxyCola")
        end
    end
})

--杀手背后透视
Tabs.Esp:Button({
    Title = "杀手背后透视 (两次)",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/4d4uHMdH"))()
        WindUI:Notify({ Title = "你好", Content = "来自 bublik6241 的问候", Duration = 2 })
    end
})

local espGeneratorsActive = false
local generatorHighlights = {}
local generatorEspThread

local function clearGeneratorHighlights()
    for _, h in ipairs(generatorHighlights) do
        if h and h.Parent then h:Destroy() end
    end
    generatorHighlights = {}
end

local function createGeneratorHighlight(target)
    local highlight = Instance.new("Highlight")
    highlight.Adornee = target
    highlight.FillColor = Color3.fromRGB(255, 255, 255)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.6
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = target
    table.insert(generatorHighlights, highlight)
end

local function updateGeneratorESP()
    clearGeneratorHighlights()
    -- 在整个游戏区域中搜索，而不是特定路径
    for _, item in ipairs(Workspace:GetDescendants()) do
        -- 使用 string.find 进行部分名称匹配
        if item.Name:find("Generator") then
            if (item:IsA("Model") and item.PrimaryPart) or item:IsA("BasePart") then
                createGeneratorHighlight(item)
            end
        end
    end
end

Tabs.Esp:Toggle({
    Title = "发电机透视",
    Default = false,
    Callback = function(state)
        espGeneratorsActive = state
        if espGeneratorsActive then
            generatorEspThread = task.spawn(function()
                while espGeneratorsActive do
                    updateGeneratorESP()
                    task.wait(20)
                end
            end)
        else
            if generatorEspThread then task.cancel(generatorEspThread); generatorEspThread = nil end
            clearGeneratorHighlights()
        end
    end
})

Players.PlayerAdded:Connect(function()
    Tabs.Main:SetDropdownValues("选择要环绕的玩家", getPlayerNames())
end)

Players.PlayerRemoving:Connect(function()
    Tabs.Main:SetDropdownValues("选择要环绕的玩家", getPlayerNames())
end)

local autoBlockOn = false
local detectionRange = 18
local looseFacing = true
local strictRangeOn = true
local windupThreshold = 0.75 -- 默认 75%

local autoBlockTriggerAnims = {
    "126830014841198", "126355327951215", "121086746534252", "18885909645",
    "98456918873918", "105458270463374", "83829782357897", "125403313786645",
    "118298475669935", "82113744478546", "70371667919898", "99135633258223",
    "97167027849946", "109230267448394", "139835501033932", "126896426760253",
    "109667959938617", "126681776859538", "129976080405072", "121293883585738",
    "81639435858902", "137314737492715",
    "92173139187970"
}

local function isFacing(localRoot, targetRoot)
    local dir = (localRoot.Position - targetRoot.Position).Unit
    local dot = targetRoot.CFrame.LookVector:Dot(dir)
    return looseFacing and dot > -0.3 or dot > 0
end

local function fireRemoteBlock()
    local args = {
        "UseActorAbility",
        {
            buffer.fromstring("\"Block\"")
        }
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end

local blockConnection = nil

local function startAutoBlock()
    blockConnection = RunService.Heartbeat:Connect(function()
        local myChar = LocalPlayer.Character
        if not myChar then return end
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        local humanoid = myChar:FindFirstChildOfClass("Humanoid")
        if not myRoot or not humanoid then return end

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                local hum = plr.Character:FindFirstChildOfClass("Humanoid")
                local animTracks = hum and hum:FindFirstChildOfClass("Animator") and hum:FindFirstChildOfClass("Animator"):GetPlayingAnimationTracks()
                if hrp and (hrp.Position - myRoot.Position).Magnitude <= detectionRange then
                    for _, track in ipairs(animTracks or {}) do
                        local id = tostring(track.Animation.AnimationId):match("%d+")
                        if table.find(autoBlockTriggerAnims, id) then
                            local progress = track.TimePosition / track.Length
                            if progress < windupThreshold then -- 检查 Windup 百分比
                                if autoBlockOn and (not strictRangeOn or (hrp.Position - myRoot.Position).Magnitude <= detectionRange) then
                                    if isFacing(myRoot, hrp) then
                                        fireRemoteBlock()
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

local function stopAutoBlock()
    if blockConnection then
        blockConnection:Disconnect()
        blockConnection = nil
    end
end

Tabs.AutoBlock:Toggle({
    Title = "自动格挡(动画)",
    Default = false,
    Callback = function(state)
        autoBlockOn = state
        if state then
            startAutoBlock()
            WindUI:Notify({ Title = "自动格挡", Content = "已启用!", Duration = 1 })
        else
            stopAutoBlock()
            WindUI:Notify({ Title = "自动格挡", Content = "已禁用!", Duration = 1 })
        end
    end
})

Tabs.AutoBlock:Slider({
    Title = "检测范围(动画)",
    Step = 1,
    Value = {Min = 1, Max = 50, Default = detectionRange},
    Suffix = " 单位",
    Callback = function(val)
        detectionRange = tonumber(val) or detectionRange
    end
})

-- 新的 Windup 百分比滑块
Tabs.AutoBlock:Slider({
    Title = "Windup %",
    Step = 5,
    Value = {Min = 1, Max = 100, Default = 75},
    Suffix = "%",
    Callback = function(val)
        windupThreshold = (tonumber(val) or 75) / 100
    end
})

-- 音频AAAAAAAAAAAAAAAAAAAAAAAAAAERM
-- 已修复

Tabs.AutoBlock:Button({
    Title = "加载自动格挡 (音频)",
    Callback = function()
        local Players = game:GetService("Players")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")

        local lp = Players.LocalPlayer

        -- 状态
        local autoBlockAudioOn = false
        local detectionRange = 20
        local detectionRangeSq = detectionRange * detectionRange
        local cachedCooldown = nil
        local currentMode = "普通"
        local zoneVisibility = 0.4
        local runZoneBoost = 4
        local zoneLength = 12
        local zoneWidth = 6

        --- 新增: 攻击追踪持续时间（秒） ---
        local monitorDuration = 0.6 -- 在声音开始后追踪攻击0.6秒

        --- 新增: 需要追踪的活跃攻击表 ---
        local activeAttacks = {}

        -- 声音ID列表（攻击）
        local autoBlockTriggerSounds = {
            ["102228729296384"] = true, ["140242176732868"] = true, ["112809109188560"] = true,
            ["136323728355613"] = true, ["115026634746636"] = true, ["84116622032112"] = true,
            ["108907358619313"] = true, ["127793641088496"] = true, ["86174610237192"] = true,
            ["95079963655241"] = true, ["101199185291628"] = true, ["119942598489800"] = true,
            ["84307400688050"] = true, ["113037804008732"] = true, ["105200830849301"] = true,
            ["75330693422988"] = true, ["82221759983649"] = true, ["81702359653578"] = true,
            ["108610718831698"] = true, ["112395455254818"] = true, ["109431876587852"] = true,
            ["109348678063422"] = true, ["85853080745515"] = true, ["12222216"] = true
        }

        local soundHooks = {}

        -- 格挡助手（新的 RemoteEvent 调用）
        local function fireRemoteBlock()
            local args = {
                "UseActorAbility",
                {
                    buffer.fromstring("\"Block\"")
                }
            }
            ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
        end

        local function isFacing(localRoot, targetRoot)
            local dir = (localRoot.Position - targetRoot.Position).Unit
            local dot = targetRoot.CFrame.LookVector:Dot(dir)
            return dot > -0.3
        end

        local function extractNumericSoundId(sound)
            if not sound or not sound.SoundId then return nil end
            return tostring(sound.SoundId):match("%d+")
        end

        local function getCharacterFromDescendant(inst)
            if not inst then return nil end
            local model = inst:FindFirstAncestorOfClass("Model")
            if model and model:FindFirstChildOfClass("Humanoid") then return model end
            return nil
        end

        local function refreshUIRefs()
            local playerGui = lp:FindFirstChild("PlayerGui")
            if not playerGui then return end
            local main = playerGui:FindFirstChild("MainUI")
            if main then
                local ability = main:FindFirstChild("AbilityContainer")
                local blockBtn = ability and ability:FindFirstChild("Block")
                cachedCooldown = blockBtn and blockBtn:FindFirstChild("CooldownTime")
            else
                cachedCooldown = nil
            end
        end

        -- === 创建区域（用于 Anti Bait） ===
        local function createZoneForKiller(killer)
            if not killer:FindFirstChild("HumanoidRootPart") then return end
            if killer:FindFirstChild("BlockZone") then return end

            local hrp = killer.HumanoidRootPart
            local zone = Instance.new("Part")
            zone.Name = "BlockZone"
            zone.Anchored = false
            zone.CanCollide = false
            zone.Size = Vector3.new(zoneWidth, 7, zoneLength)
            zone.CFrame = hrp.CFrame * CFrame.new(0, 0, -4)
            zone.BrickColor = BrickColor.new("Royal purple")
            zone.Transparency = 1
            zone.Parent = killer

            local weld = Instance.new("WeldConstraint")
            weld.Part0 = hrp
            weld.Part1 = zone
            weld.Parent = zone

            local highlight = Instance.new("Highlight")
            highlight.Name = "ZoneHighlight"
            highlight.Adornee = zone
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.FillColor = Color3.fromRGB(180, 0, 255)
            highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
            highlight.Enabled = false
            highlight.Parent = zone
        end

        -- === 动态更新区域大小 ===
        local function updateZoneSize(killer)
            local zone = killer:FindFirstChild("BlockZone")
            local hum = killer:FindFirstChildOfClass("Humanoid")

            if zone and hum then
                local baseSize = Vector3.new(zoneWidth, 7, zoneLength)
                if hum.MoveDirection.Magnitude > 0.1 then
                    zone.Size = Vector3.new(baseSize.X, baseSize.Y, baseSize.Z + runZoneBoost)
                else
                    zone.Size = baseSize
                end
            end
        end

        -- === 格挡逻辑（带监控） ===

        local function registerAttackForMonitoring(sound)
            if not autoBlockAudioOn or not sound or not sound:IsA("Sound") or not sound.IsPlaying then return end
            if activeAttacks[sound] then return end

            local id = extractNumericSoundId(sound)
            if not id or not autoBlockTriggerSounds[id] then return end

            local myChar = lp.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if not myRoot then return end

            local soundPart = sound.Parent
            if not (soundPart and soundPart.Parent) then return end

            local char = getCharacterFromDescendant(soundPart)
            local plr = char and Players:GetPlayerFromCharacter(char)
            if not plr or plr == lp then return end

            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local dvec = hrp.Position - myRoot.Position
            if dvec:Dot(dvec) > detectionRangeSq then return end

            activeAttacks[sound] = {
                killer = char,
                endTime = tick() + monitorDuration
            }
        end

        local function monitorActiveAttacks()
            if not autoBlockAudioOn or next(activeAttacks) == nil then return end

            local myChar = lp.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if not myRoot then return end

            if cachedCooldown and cachedCooldown.Text ~= "" then
                activeAttacks = {}
                return
            end

            local t = tick()

            for sound, attackData in pairs(activeAttacks) do
                if not sound or sound.Parent == nil or t > attackData.endTime then
                    activeAttacks[sound] = nil
                    continue
                end

                local killerChar = attackData.killer
                if not killerChar or killerChar.Parent == nil then
                    activeAttacks[sound] = nil
                    continue
                end

                local killerRoot = killerChar:FindFirstChild("HumanoidRootPart")
                local killerZone = killerChar:FindFirstChild("BlockZone")
                if not killerRoot then
                    activeAttacks[sound] = nil
                    continue
                end

                if isFacing(myRoot, killerRoot) then
                    if currentMode == "普通" then
                        fireRemoteBlock()
                        activeAttacks = {}
                        break
                    elseif currentMode == "普通+反诱饵" and killerZone then
                        local touchingZone = (myRoot.Position - killerZone.Position).Magnitude <= (killerZone.Size.Magnitude / 2 + 2)
                        if touchingZone then
                            fireRemoteBlock()
                            activeAttacks = {}
                            break
                        end
                    end
                end
            end
        end

        local function hookSound(sound)
            if not sound or not sound:IsA("Sound") or soundHooks[sound] then return end

            local playedConn = sound.Played:Connect(function() pcall(registerAttackForMonitoring, sound) end)
            local propConn = sound:GetPropertyChangedSignal("IsPlaying"):Connect(function()
                if sound.IsPlaying then pcall(registerAttackForMonitoring, sound) end
            end)

            local destroyConn
            destroyConn = sound.Destroying:Connect(function()
                if playedConn and playedConn.Connected then playedConn:Disconnect() end
                if propConn and propConn.Connected then propConn:Disconnect() end
                if destroyConn and destroyConn.Connected then destroyConn:Disconnect() end
                soundHooks[sound] = nil
                activeAttacks[sound] = nil
            end)

            soundHooks[sound] = {playedConn, propConn, destroyConn}

            if sound.IsPlaying then
                task.spawn(function() pcall(registerAttackForMonitoring, sound) end)
            end
        end

        local function updateZonesVisibility()
            local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
            for _, killer in ipairs(killersFolder:GetChildren()) do
                local zone = killer:FindFirstChild("BlockZone")
                if zone then
                    local hl = zone:FindFirstChild("ZoneHighlight")
                    if currentMode == "普通" then
                        zone.Transparency = 1
                        if hl then hl.Enabled = false end
                    elseif currentMode == "普通+反诱饵" then
                        zone.Transparency = zoneVisibility
                        if hl then hl.Enabled = true end
                    end
                end
            end
        end

        task.spawn(function()
            while task.wait(5) do
                if not autoBlockAudioOn then continue end
                local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
                for _, killer in ipairs(killersFolder:GetChildren()) do
                    createZoneForKiller(killer)
                end
                updateZonesVisibility()
            end
        end)

        RunService.Heartbeat:Connect(function()
            if not autoBlockAudioOn then return end
            local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
            for _, killer in ipairs(killersFolder:GetChildren()) do
                updateZoneSize(killer)
            end
            monitorActiveAttacks()
        end)

        lp.CharacterAdded:Connect(function()
            task.delay(0.5, refreshUIRefs)
        end)
        refreshUIRefs()

        for _, desc in ipairs(game:GetDescendants()) do
            if desc:IsA("Sound") then pcall(hookSound, desc) end
        end
        game.DescendantAdded:Connect(function(desc)
            if desc:IsA("Sound") then pcall(hookSound, desc) end
        end)

        -- GUI
        Tabs.AutoBlock:Toggle({
            Title = "自动格挡 (音频)",
            Default = autoBlockAudioOn,
            Callback = function(state)
                autoBlockAudioOn = state
            end
        })

        Tabs.AutoBlock:Slider({
            Title = "检测范围 (音频)",
            Step = 1,
            Value = {Min = 1, Max = 100, Default = detectionRange},
            Suffix = " 单位",
            Callback = function(val)
                detectionRange = val
                detectionRangeSq = val * val
            end
        })

        Tabs.AutoBlock:Dropdown({
            Title = "自动格挡模式",
            Values = {"普通", "普通+反诱饵"},
            Value = "普通",
            Multi = false,
            AllowNone = false,
            Callback = function(choice)
                currentMode = choice
                updateZonesVisibility()
            end
        })

        Tabs.AutoBlock:Slider({
            Title = "攻击验证持续时间",
            Step = 0.1,
            Value = {Min = 0.1, Max = 2.0, Default = 0.6},
            Suffix = " 秒",
            Callback = function(val)
                monitorDuration = val
            end
        })

        Tabs.AutoBlock:Slider({
            Title = "区域可见度",
            Step = 1,
            Value = {Min = 0, Max = 10, Default = 6},
            Suffix = " /10",
            Callback = function(val)
                zoneVisibility = 1 - (val / 10)
                updateZonesVisibility()
            end
        })

        Tabs.AutoBlock:Slider({
            Title = "区域长度",
            Step = 0.1,
            Value = {Min = 1, Max = 30, Default = 12},
            Suffix = " 单位",
            Callback = function(val)
                zoneLength = val
            end
        })

        Tabs.AutoBlock:Slider({
            Title = "区域宽度",
            Step = 0.1,
            Value = {Min = 1, Max = 15, Default = 6},
            Suffix = " 单位",
            Callback = function(val)
                zoneWidth = val
            end
        })

        Tabs.AutoBlock:Slider({
            Title = "区域增强(如果杀手有延迟或你延迟高)",
            Step = 1,
            Value = {Min = 0, Max = 10, Default = 4},
            Suffix = " 单位",
            Callback = function(val)
                runZoneBoost = val
            end
        })
    end
})

-- 拳击
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

local autoPunchOn = false
local flingPunchOn = false
local flingPower = 5000000
local aimPunch = true -- 启用预测转向
local hiddenfling = false

local punchConnection = nil
local flingConnection = nil

-- === 击飞循环 ===
local function startFlingLoop()
    if flingConnection then return end
    flingConnection = RunService.Heartbeat:Connect(function()
        if hiddenfling then
            local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if hrp then
                local vel = hrp.Velocity
                hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
                task.wait(0.1)
                hrp.Velocity = Vector3.new(0, 0, 0)
            end
        end
    end)
end

local function stopFlingLoop()
    if flingConnection then
        flingConnection:Disconnect()
        flingConnection = nil
    end
end

-- === 自动拳击循环 ===
local function startPunchLoop()
    if punchConnection then return end
    punchConnection = RunService.Heartbeat:Connect(function()
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if not hrp or not humanoid then return end

        -- 寻找最近的玩家
        local closestPlayer = nil
        local closestDist = math.huge
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                local targetHrp = plr.Character:FindFirstChild("HumanoidRootPart")
                if targetHrp then
                    local dist = (hrp.Position - targetHrp.Position).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        closestPlayer = plr
                    end
                end
            end
        end

        -- 如果启用了预测转向，则瞄准最近的玩家
        if aimPunch and closestPlayer then
            local targetHrp = closestPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetHrp then
                local dir = (targetHrp.Position - hrp.Position).Unit
                hrp.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + dir)
            end
        end

        -- 触发拳击
        local args = {
            "UseActorAbility",
            {
                buffer.fromstring("\"Punch\"")
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
    end)
end

local function stopPunchLoop()
    if punchConnection then
        punchConnection:Disconnect()
        punchConnection = nil
    end
end

-- === GUI ===
Tabs.Misc:Toggle({
    Title = "自动拳击",
    Default = false,
    Callback = function(state)
        autoPunchOn = state
        if state then
            startPunchLoop()
            WindUI:Notify({ Title = "自动拳击", Content = "已启用!", Duration = 1 })
        else
            stopPunchLoop()
            WindUI:Notify({ Title = "自动拳击", Content = "已禁用!", Duration = 1 })
        end
    end
})

Tabs.Misc:Toggle({
    Title = "击飞拳击",
    Default = false,
    Callback = function(state)
        flingPunchOn = state
        if state then
            startFlingLoop()
            WindUI:Notify({ Title = "击飞拳击", Content = "已启用!", Duration = 1 })
        else
            stopFlingLoop()
            WindUI:Notify({ Title = "击飞拳击", Content = "已禁用!", Duration = 1 })
        end
    end
})

Tabs.Misc:Toggle({
    Title = "隐藏击飞",
    Default = false,
    Callback = function(state)
        hiddenfling = state
    end
})

Tabs.Misc:Toggle({
    Title = "预测转向",
    Default = true,
    Callback = function(state)
        aimPunch = state
    end
})

Tabs.Misc:Slider({
    Title = "击飞力量",
    Step = 1,
    Value = {Min = 1, Max = 10000000, Default = flingPower},
    Suffix = " 力量",
    Callback = function(val)
        flingPower = tonumber(val) or flingPower
    end
})

-- 自动眩晕
local autoStunOn = false
local stunRange = 20
local stunConnection = nil

local function startStunLoop()
    if stunConnection then return end
    stunConnection = RunService.Heartbeat:Connect(function()
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                local targetHrp = plr.Character:FindFirstChild("HumanoidRootPart")
                if targetHrp and (hrp.Position - targetHrp.Position).Magnitude <= stunRange then
                    local args = {
                        "UseActorAbility",
                        {
                            buffer.fromstring("\"Stun\"")
                        }
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
                    break
                end
            end
        end
    end)
end

local function stopStunLoop()
    if stunConnection then
        stunConnection:Disconnect()
        stunConnection = nil
    end
end

Tabs.Auto_Stun:Toggle({
    Title = "自动眩晕",
    Default = false,
    Callback = function(state)
        autoStunOn = state
        if state then
            startStunLoop()
            WindUI:Notify({ Title = "自动眩晕", Content = "已启用!", Duration = 1 })
        else
            stopStunLoop()
            WindUI:Notify({ Title = "自动眩晕", Content = "已禁用!", Duration = 1 })
        end
    end
})

Tabs.Auto_Stun:Slider({
    Title = "眩晕范围",
    Step = 1,
    Value = {Min = 1, Max = 50, Default = stunRange},
    Suffix = " 单位",
    Callback = function(val)
        stunRange = tonumber(val) or stunRange
    end
})

-- 随机
Tabs.Random:Button({
    Title = "无限跳跃",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/0w14dFh2"))()
        WindUI:Notify({ Title = "你好", Content = "来自 bublik6241 的问候", Duration = 2 })
    end
})

Tabs.Random:Button({
    Title = "飞行 (X)",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/7ghNV2y1"))()
        WindUI:Notify({ Title = "你好", Content = "来自 bublik6241 的问候", Duration = 2 })
    end
})

Tabs.Random:Button({
    Title = "穿墙 (C)",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/2Bw1e1eW"))()
        WindUI:Notify({ Title = "你好", Content = "来自 bublik6241 的问候", Duration = 2 })
    end
})

Tabs.Random:Button({
    Title = "速度 (Z)",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/3dK2yZ5M"))()
        WindUI:Notify({ Title = "你好", Content = "来自 bublik6241 的问候", Duration = 2 })
    end
})

Tabs.Random:Button({
    Title = "夜视",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/1p1bV0fL"))()
        WindUI:Notify({ Title = "你好", Content = "来自 bublik6241 的问候", Duration = 2 })
    end
})

-- 攻击范围扩大
local hitboxExpanderOn = false
local hitboxSize = 10
local hitboxConnection = nil

local function startHitboxLoop()
    if hitboxConnection then return end
    hitboxConnection = RunService.Heartbeat:Connect(function()
        local char = LocalPlayer.Character
        if not char then return end
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end

        -- 扩大所有幸存者的攻击范围
        local survivorsFolder = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return end

        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
                local hrp = survivor.HumanoidRootPart
                hrp.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                hrp.Transparency = 0.5
                hrp.CanCollide = false
            end
        end
    end)
end

local function stopHitboxLoop()
    if hitboxConnection then
        hitboxConnection:Disconnect()
        hitboxConnection = nil
    end

    -- 重置所有幸存者的攻击范围
    local survivorsFolder = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Survivors")
    if not survivorsFolder then return end

    for _, survivor in ipairs(survivorsFolder:GetChildren()) do
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
            local hrp = survivor.HumanoidRootPart
            hrp.Size = Vector3.new(2, 2, 1)
            hrp.Transparency = 0
            hrp.CanCollide = true
        end
    end
end

Tabs.Hitbox_expander:Toggle({
    Title = "攻击范围扩大",
    Default = false,
    Callback = function(state)
        hitboxExpanderOn = state
        if state then
            startHitboxLoop()
            WindUI:Notify({ Title = "攻击范围扩大", Content = "已启用!", Duration = 1 })
        else
            stopHitboxLoop()
            WindUI:Notify({ Title = "攻击范围扩大", Content = "已禁用!", Duration = 1 })
        end
    end
})

Tabs.Hitbox_expander:Slider({
    Title = "攻击范围大小",
    Step = 1,
    Value = {Min = 1, Max = 50, Default = hitboxSize},
    Suffix = " 单位",
    Callback = function(val)
        hitboxSize = tonumber(val) or hitboxSize
    end
})

-- 发电机
local autoRepairOn = false
local repairRange = 10
local repairConnection = nil

local function findNearestGenerator()
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearestGen = nil
    local nearestDist = math.huge

    for _, item in ipairs(Workspace:GetDescendants()) do
        if item.Name:find("Generator") and (item:IsA("Model") or item:IsA("BasePart")) then
            local part = item:IsA("Model") and item.PrimaryPart or item
            if part then
                local dist = (hrp.Position - part.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearestGen = item
                end
            end
        end
    end

    return nearestGen, nearestDist
end

local function startRepairLoop()
    if repairConnection then return end
    repairConnection = RunService.Heartbeat:Connect(function()
        local nearestGen, dist = findNearestGenerator()
        if nearestGen and dist <= repairRange then
            -- 触发修理动作
            local args = {
                "InteractWithGenerator",
                {
                    buffer.fromstring("\"Repair\"")
                }
            }
            game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
        end
    end)
end

local function stopRepairLoop()
    if repairConnection then
        repairConnection:Disconnect()
        repairConnection = nil
    end
end

Tabs.Generator:Toggle({
    Title = "自动修理发电机",
    Default = false,
    Callback = function(state)
        autoRepairOn = state
        if state then
            startRepairLoop()
            WindUI:Notify({ Title = "自动修理", Content = "已启用!", Duration = 1 })
        else
            stopRepairLoop()
            WindUI:Notify({ Title = "自动修理", Content = "已禁用!", Duration = 1 })
        end
    end
})

Tabs.Generator:Slider({
    Title = "修理范围",
    Step = 1,
    Value = {Min = 1, Max = 50, Default = repairRange},
    Suffix = " 单位",
    Callback = function(val)
        repairRange = tonumber(val) or repairRange
    end
})

-- 传送
local teleporting = false

local function teleportToPlayer(playerName)
    local targetPlayer = nil
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Name:lower():find(playerName:lower()) then
            targetPlayer = plr
            break
        end
    end

    if not targetPlayer or not targetPlayer.Character then
        WindUI:Notify({ Title = "传送", Content = "玩家未找到或不在游戏中!", Duration = 2 })
        return
    end

    local targetHrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    local myChar = LocalPlayer.Character
    local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")

    if not targetHrp or not myHrp then
        WindUI:Notify({ Title = "传送", Content = "无法传送!", Duration = 2 })
        return
    end

    teleporting = true
    myHrp.CFrame = targetHrp.CFrame
    task.wait(0.5)
    teleporting = false
    WindUI:Notify({ Title = "传送", Content = "已传送到 " .. targetPlayer.Name, Duration = 2 })
end

Tabs.Teleport:Textbox({
    Title = "传送到玩家",
    Placeholder = "输入玩家名称",
    Callback = function(text)
        if text and text ~= "" then
            teleportToPlayer(text)
        end
    end
})

-- 传送到发电机
Tabs.Teleport:Button({
    Title = "传送到发电机",
    Callback = function()
        local nearestGen = findNearestGenerator()
        local myChar = LocalPlayer.Character
        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")

        if not nearestGen or not myHrp then
            WindUI:Notify({ Title = "传送", Content = "未找到发电机!", Duration = 2 })
            return
        end

        local part = nearestGen:IsA("Model") and nearestGen.PrimaryPart or nearestGen
        if part then
            teleporting = true
            myHrp.CFrame = part.CFrame + Vector3.new(0, 3, 0)
            task.wait(0.5)
            teleporting = false
            WindUI:Notify({ Title = "传送", Content = "已传送到发电机!", Duration = 2 })
        end
    end
})

-- 传送到出口
Tabs.Teleport:Button({
    Title = "传送到出口",
    Callback = function()
        local exit = Workspace:FindFirstChild("Exit") or Workspace:FindFirstChild("ExitDoor")
        local myChar = LocalPlayer.Character
        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")

        if not exit or not myHrp then
            WindUI:Notify({ Title = "传送", Content = "未找到出口!", Duration = 2 })
            return
        end

        local part = exit:IsA("Model") and exit.PrimaryPart or exit
        if part then
            teleporting = true
            myHrp.CFrame = part.CFrame + Vector3.new(0, 3, 0)
            task.wait(0.5)
            teleporting = false
            WindUI:Notify({ Title = "传送", Content = "已传送到出口!", Duration = 2 })
        end
    end
})

-- 致谢
Tabs.Credits:Label({ Title = "脚本作者: RINGTA" })
Tabs.Credits:Label({ Title = "GUI 作者: BUBLIK6241" })
Tabs.Credits:Label({ Title = "特别感谢: WindUI 库" })
Tabs.Credits:Label({ Title = "版本: 1.0.0" })

Tabs.Credits:Button({
    Title = "复制 Discord 邀请",
    Callback = function()
        setclipboard("https://discord.gg/example")
        WindUI:Notify({ Title = "Discord", Content = "邀请链接已复制到剪贴板!", Duration = 2 })
    end
})

WindUI:Notify({ Title = "RINGTA 脚本", Content = "已成功加载! 享受游戏!", Duration = 3 })
