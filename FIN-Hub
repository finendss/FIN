local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/FIN-Ui/refs/heads/main/FIN-WindUi"))()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

WindUI:Popup({
    Title = "FIN-Hub",
    Icon = "sparkles",
    Content = "尊敬的：" .. game.Players.LocalPlayer.Name,
    Buttons = {
        {
            Title = "启动",
            Icon = "arrow-right",
            Variant = "Primary",
            Callback = function()
                print("启动")
            end
        }
    }
})

local Window = WindUI:CreateWindow({
    Title = "FIN-Hub",
    Icon = "sparkles",
    Author = "By 鑫晴",
    Folder = "DefenseSystem",
    Size = UDim2.fromOffset(400, 400),
    Theme = "Dark"
})

local TimeTag = Window:Tag({
    Title = "00:00",
    Color = Color3.fromHex("#30ff6a")
})

local hue = 0
task.spawn(function()
    while true do
        local now = os.date("*t")
        local hours = string.format("%02d", now.hour)
        local minutes = string.format("%02d", now.min)
        
        hue = (hue + 0.01) % 1
        local color = Color3.fromHSV(hue, 1, 1)
        
        TimeTag:SetTitle(hours .. ":" .. minutes)

        task.wait(0.06)
    end
end)

Window:Tag({
    Title = "宝宝",
    Color = Color3.fromHex("#315dff")
})

task.wait(0.3)

Window:EditOpenButton({
    Title = "FIN-Hub",
    Icon = "monitor",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromHex("FF0000")),
        ColorSequenceKeypoint.new(0.66, Color3.fromHex("0000FF")),
        ColorSequenceKeypoint.new(0.83, Color3.fromHex("4B0082")),
        ColorSequenceKeypoint.new(1, Color3.fromHex("9400D3"))
    }),
    Draggable = true,
})

task.wait(0.2)

local MainTab = Window:Tab({
    Title = "主页(必看)",
    Icon = "zap",
    Locked = false,
})

MainTab:Section({Title = "免责声明", TextXAlignment = "Left", TextSize = 17})

MainTab:Paragraph({
    Title = "被封服务器与FIN-Hub无关",
    Desc = "被封号与FIN-Hub无关",
})

MainTab:Section({Title = "信息", TextXAlignment = "Left", TextSize = 17})

MainTab:Paragraph({
    Title = "作者:鑫晴",
    Desc = "神秘的人",
})

MainTab:Paragraph({
    Title = "此剧本为免费剧本",
    Desc = "倒卖的人死全家",
})

MainTab:Paragraph({
    Title = "当前服务器ID: " .. game.PlaceId,
    Desc = "感谢你的支持",
})

MainTab:Section({Title = "获取更多信息", TextXAlignment = "Left", TextSize = 17})

MainTab:Paragraph({
    Title = "获取FIN-Hub主群qq",
    Desc = "以此获取最新内容",
    ImageSize = 20,
    Color = "Grey",
    Buttons = {
        {
            Title = "复制",
            Icon = "copy",
            Variant = "Tertiary",
            Callback = function()
                if setclipboard then
                    setclipboard("951740588")
                    WindUI:Notify({
                        Title = "已复制",
                        Content = "已复制到剪贴板",
                        Duration = 5
                    })
                else
                    WindUI:Notify({
                        Title = "错误",
                        Content = "复制出问题了",
                        Duration = 5
                    })
                end
            end
        }
    }
})

MainTab:Paragraph({
    Title = "获取FIN-Hub的Discord",
    Desc = "以此获取信息",
    ImageSize = 20,
    Color = "Grey",
    Buttons = {
        {
            Title = "复制",
            Icon = "copy",
            Variant = "Tertiary",
            Callback = function()
                if setclipboard then
                    setclipboard("https://discord.gg/MNqw4EET")
                    WindUI:Notify({
                        Title = "已复制",
                        Content = "已复制到剪贴板",
                        Duration = 5
                    })
                else
                    WindUI:Notify({
                        Title = "错误",
                        Content = "复制出问题了",
                        Duration = 5
                    })
                end
            end
        }
    }
})

local Tab = Window:Tab({
    Title = "通用",
    Icon = "drama",
    Locked = false,
})

Tab:Slider({
    Title = "奔跑速度",
    Value = {
        Min = 16,
        Max = 500,
        Default = 16,
    },
    Increment = 1,
    Callback = function(value)
        if game.Players.LocalPlayer.Character then
            local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = value
            end
        end
    end
})

Tab:Slider({
    Title = "跳跃高度",
    Value = {
        Min = 50,
        Max = 400,
        Default = 50,
    },
    Increment = 1,
    Callback = function(value)
        if game.Players.LocalPlayer.Character then
            local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.JumpPower = value
            end
        end
    end
})

Tab:Slider({
    Title = "重力(万有引力)",
    Value = {
        Min = 50,
        Max = 500,
        Default = 196,
    },
    Increment = 1,
    Callback = function(value)
        game.Workspace.Gravity = value
    end
})

Tab:Toggle({
    Title = "夜视",
    Default = false,
    Callback = function(Value)
        if Value then
            game.Lighting.Ambient = Color3.new(1, 1, 1)
        else
            game.Lighting.Ambient = Color3.new(0, 0, 0)
        end
    end
})

local clipConnection = nil

Tab:Toggle({
    Title = "穿墙",
    Default = false,
    Callback = function(enabled)
        if clipConnection then
            clipConnection:Disconnect()
            clipConnection = nil
        end
        
        if enabled then
            clipConnection = RunService.Stepped:Connect(function()
                local char = Players.LocalPlayer.Character
                if char then
                    for _, part in ipairs(char:GetChildren()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
            WindUI:Notify({
                Title = "已开启穿墙",
                Content = "ok了老铁",
                Duration = 3
            })
        else
            local char = Players.LocalPlayer.Character
            if char then
                for _, part in ipairs(char:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
            WindUI:Notify({
                Title = "已关闭穿墙",
                Content = "不ok了老铁",
                Duration = 5
            })
        end
    end
})

Tab:Toggle({
    Title = "绘制玩家",
    Default = false,
    Callback = function(state)
        if state then
            local FillColor = Color3.fromRGB(255, 0, 0)
            local DepthMode = "AlwaysOnTop"
            local FillTransparency = 0.5
            local OutlineColor = Color3.fromRGB(255,255,255)
            local OutlineTransparency = 0

            local CoreGui = game:GetService("CoreGui")
            local Players = game:GetService("Players")
            local connections = {}
            
            local Storage = Instance.new("Folder")
            Storage.Parent = CoreGui
            Storage.Name = "Highlight_Storage"

            local function Highlight(plr)
                if not Storage or not Storage.Parent then return end
                
                local Highlight = Instance.new("Highlight")
                Highlight.Name = plr.Name
                Highlight.FillColor = FillColor
                Highlight.DepthMode = DepthMode
                Highlight.FillTransparency = FillTransparency
                Highlight.OutlineColor = OutlineColor
                Highlight.OutlineTransparency = 0
                Highlight.Parent = Storage
                
                local plrchar = plr.Character
                if plrchar then
                    Highlight.Adornee = plrchar
                end

                connections[plr] = plr.CharacterAdded:Connect(function(char)
                    if Highlight and Highlight.Parent then
                        Highlight.Adornee = char
                    end
                end)
            end

            connections.playerAdded = Players.PlayerAdded:Connect(Highlight)
            
            for i,v in next, Players:GetPlayers() do
                Highlight(v)
            end

            connections.playerRemoving = Players.PlayerRemoving:Connect(function(plr)
                if Storage and Storage.Parent then
                    local plrname = plr.Name
                    if Storage[plrname] then
                        Storage[plrname]:Destroy()
                    end
                end
                if connections[plr] then
                    connections[plr]:Disconnect()
                    connections[plr] = nil
                end
            end)
            
            Storage:SetAttribute("Connections", connections)
        else
            local CoreGui = game:GetService("CoreGui")
            local Storage = CoreGui:FindFirstChild("Highlight_Storage")
            if Storage then
                local connections = Storage:GetAttribute("Connections")
                if connections then
                    for key, connection in pairs(connections) do
                        if connection and typeof(connection) == "RBXScriptConnection" then
                            connection:Disconnect()
                        end
                    end
                end
                Storage:Destroy()
            end
        end
    end
})

Tab:Button({
    Title = "FIN-飞行",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/FIN-function/refs/heads/main/FIN-Fly"))()
    end
})

Tab:Button({
    Title = "FIN-飞车",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/FIN-function/refs/heads/main/FIN-FlyCar"))()
    end
})

Tab:Button({
    Title = "FE-死亡笔记",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/FIN-function/refs/heads/main/FIN-DeathNote"))()
    end
})

Tab:Button({
    Title = "无限跳",
    Callback = function()
        game:GetService("UserInputService").JumpRequest:Connect(function()
            local character = game:GetService("Players").LocalPlayer.Character
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState("Jumping")
                end
            end
        end)
        WindUI:Notify({
            Title = "已开启无限跳",
            Content = "跳跳虎",
            Duration = 3
        })
    end
})

Tab:Button({
    Title = "踏空行走",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/GhostPlayer352/Test4/main/Float'))()
    end
})

Tab:Button({
    Title = "玩家进入服务器提示",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/boyscp/scriscriptsc/main/bbn.lua"))()
    end
})

Tab:Button({
    Title = "FPS优化",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/gclich/FPS-X-GUI/main/FPS_X.lua"))()
    end
})

Tab:Button({
    Title = "电脑键盘",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/advxzivhsjjdhxhsidifvsh/mobkeyboard/main/main.txt", true))()
    end
})

Tab:Button({
    Title = "电脑鼠标",
    Callback = function()
        loadstring(game:HttpGet(('https://pastefy.ga/V75mqzaz/raw'),true))()
    end
})

Tab:Button({
    Title = "反挂机V2",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/9fFu43FF"))()
    end
})

Tab:Section({Title = "光影与画质", TextXAlignment = "Left", TextSize = 17})

Tab:Button({
    Title = "光影 1",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/FIN-function/refs/heads/main/Lightandshadow-1"))()
    end
})

Tab:Button({
    Title = "光影 2",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/FIN-function/refs/heads/main/LightandShadow-2"))()
    end
})

Tab:Section({Title = "FE", TextXAlignment = "Left", TextSize = 17})

Tab:Button({
    Title = "无头断腿美化",
    Callback = function()
         loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Permanent-Headless-And-korblox-Script-4140"))()
    end
})

Tab:Button({
    Title = "动画中心",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/GamingScripter/Animation-Hub/main/Animation%20Gui", true))()    
    end
})

Tab:Button({
    Title = "变成其他玩家(r6)",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/XR4sGcgJ"))()
    end
})

Tab:Button({
    Title = "变成1x1x1x1",
    Callback = function()
        loadstring(game:HttpGet(('https://pastebin.com/raw/JipYNCht'),true))()
    end
})

Tab:Button({
    Title = "无敌少侠飞行动作(r15)",
    Callback = function()
        loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Invinicible-Flight-R15-45414"))()
    end
})

Tab:Button({
    Title = "无敌少侠飞行动作(r6)",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/ke9460394-dot/ugik/refs/heads/main/%E6%97%A0%E6%95%8C%E5%B0%91%E4%BE%A0%E9%A3%9E%E8%A1%8Cr6.txt"))()
    end
})

local Tab2 = Window:Tab({
    Title = "监狱人生",
    Icon = "drama",
    Locked = false,
})

Tab2:Button({
    Title = "子追(队伍检测)",
    Callback = function()
        local Workspace = game:GetService("Workspace")
        local Players = game:GetService("Players")
        local Teams = game:GetService("Teams")
        local LocalPlayer = Players.LocalPlayer
        local Camera = Workspace.CurrentCamera
        local old

        local FOV_Circle = Drawing.new("Circle")
        FOV_Circle.Visible = true
        FOV_Circle.Radius = 60
        FOV_Circle.Color = Color3.fromRGB(255, 255, 255)
        FOV_Circle.Thickness = 1
        FOV_Circle.Transparency = 1
        FOV_Circle.Filled = false
        FOV_Circle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

        Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
            FOV_Circle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        end)

        local function isEnemy(targetPlayer)
            if not targetPlayer then return true end
            local localTeam = LocalPlayer.Team
            local targetTeam = targetPlayer.Team
            if not localTeam or not targetTeam then
                return true
            end
            return localTeam ~= targetTeam
        end

        local function getClosestHead()
            local closestHead
            local closestDistance = math.huge
            local cameraDirection = Camera.CFrame.LookVector
            local cameraPos = Camera.CFrame.Position
            
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local character = player.Character
                    local head = character:FindFirstChild("Head")
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    local forcefield = character:FindFirstChild("ForceField")
                    
                    if head and humanoid and not forcefield and humanoid.Health > 0 and isEnemy(player) then
                        local directionToHead = (head.Position - cameraPos).Unit
                        local angle = math.deg(math.acos(cameraDirection:Dot(directionToHead)))
                        
                        if angle <= FOV_Circle.Radius then
                            local distance = (head.Position - cameraPos).Magnitude
                            if distance < closestDistance then
                                closestHead = head
                                closestDistance = distance
                            end
                        end
                    end
                end
            end
            
            return closestHead
        end

        old = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if (method == "Raycast" or method == "FindPartOnRay") and not checkcaller() and self == Workspace then
                local origin, direction
                if method == "Raycast" then
                    origin = args[1]
                    direction = args[2]
                else
                    local ray = args[1]
                    if typeof(ray) == "Ray" then
                        origin = ray.Origin
                        direction = ray.Direction
                    end
                end
                
                if origin and direction then
                    local closestHead = getClosestHead()
                    if closestHead then
                        return {
                            Instance = closestHead,
                            Position = closestHead.Position,
                            Normal = (closestHead.Position - origin).Unit,
                            Material = Enum.Material.Plastic
                        }
                    end
                end
            end
            
            return old(self, ...)
        end)

        return function()
            if old then
                hookmetamethod(game, "__namecall", old)
                old = nil
            end
            if FOV_Circle then
                FOV_Circle:Remove()
                FOV_Circle = nil
            end
        end
    end
})

Tab2:Button({
    Title = "FE-变成钢铁侠(别人可见)",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/7prijqYH"))()
    end
})

Tab2:Button({
    Title = "手里剑(秒杀别人)",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/mSLiAZHk"))()
    end
})

Tab2:Button({
    Title = "FE-无敌模式(别人可见)",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/LdTVujTA"))()
    end
})

Tab2:Button({
    Title = "杀死所有人(开启后无法关闭)",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/kXjfpFPh"))()
    end
})

Tab2:Button({
    Title = "逮捕囚犯",
    Callback = function()
        Player = game.Players.LocalPlayer
        Pcf = Player.Character.HumanoidRootPart.CFrame
        for i,v in pairs(game.Teams.Criminals:GetPlayers()) do
            if v.Name ~= Player.Name then
                local i = 10
                repeat
                    wait()
                    i = i-1
                    game.Workspace.Remote.arrest:InvokeServer(v.Character.HumanoidRootPart)
                    Player.Character.HumanoidRootPart.CFrame = v.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 1)
                until i == 0
            end
        end
    end
})

Tab2:Button({
    Title = "传送至警卫室",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(847.7261352539062, 98.95999908447266, 2267.387451171875)
    end
})

Tab2:Button({
    Title = "传送至监狱室",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(919.2575073242188, 98.95999908447266, 2379.74169921875)
    end
})

Tab2:Button({
    Title = "传送至罪犯复活点位",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-937.5891723632812, 93.09876251220703, 2063.031982421875)
    end
})

Tab2:Button({
    Title = "传送至监狱室外",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(760.6033325195312, 96.96992492675781, 2475.405029296875)
    end
})

local Tab3 = Window:Tab({
    Title = "自然灾害",
    Icon = "drama",
    Locked = false,
})

Tab3:Button({
    Title = "磁吸黑洞",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/FIN-function/refs/heads/main/Magnetic-black-hole"))()
    end
})

Tab3:Button({
    Title = "黑洞v1",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/FIN-function/refs/heads/main/Black-hole-v1"))()
    end
})

Tab3:Button({
    Title = "黑洞v2",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/FIN-function/refs/heads/main/Black-hole-v2"))()
    end
})

local partDestroyerEnabled = false
local partDestroyerConnection

Tab3:Toggle({
    Title = "崩飞零件",
    Callback = function(state)
        partDestroyerEnabled = state
        
        if partDestroyerEnabled then
            WindUI:Notify({
                Title = "已开启零件崩飞",
                Content = "所有零件正在崩飞！",
                Duration = 3
            })
            
            local function protectedCall(func, ...)
                local success, result = pcall(func, ...)
                if not success then
                    warn("执行错误: " .. tostring(result))
                end
                return success, result
            end

            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local Workspace = game:GetService("Workspace")
            local LocalPlayer = Players.LocalPlayer

            if not getgenv().Network then
                getgenv().Network = {
                    BaseParts = {},
                    Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
                }

                Network.RetainPart = function(Part)
                    if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
                        table.insert(Network.BaseParts, Part)
                        protectedCall(function()
                            Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                            Part.CanCollide = false
                        end)
                    end
                end

                local function EnablePartControl()
                    protectedCall(function()
                        LocalPlayer.ReplicationFocus = Workspace
                    end)
                    
                    RunService.Heartbeat:Connect(function()
                        protectedCall(function()
                            sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                            for _, Part in pairs(Network.BaseParts) do
                                if Part:IsDescendantOf(Workspace) then
                                    Part.Velocity = Network.Velocity
                                end
                            end
                        end)
                    end)
                end

                EnablePartControl()
            end

            local function ForcePart(v)
                if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChild("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
                    for _, x in next, v:GetChildren() do
                        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
                            protectedCall(function() x:Destroy() end)
                        end
                    end
                    if v:FindFirstChild("Attachment") then
                        protectedCall(function() v:FindFirstChild("Attachment"):Destroy() end)
                    end
                    if v:FindFirstChild("AlignPosition") then
                        protectedCall(function() v:FindFirstChild("AlignPosition"):Destroy() end)
                    end
                    if v:FindFirstChild("Torque") then
                        protectedCall(function() v:FindFirstChild("Torque"):Destroy() end)
                    end
                    
                    protectedCall(function()
                        v.CanCollide = false
                        
                        local randomForce = Instance.new("BodyVelocity", v)
                        randomForce.Velocity = Vector3.new(
                            math.random(-100, 100),
                            math.random(50, 100),
                            math.random(-100, 100)
                        )
                        randomForce.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                        
                        local randomTorque = Instance.new("BodyAngularVelocity", v)
                        randomTorque.AngularVelocity = Vector3.new(
                            math.random(-20, 20),
                            math.random(-20, 20),
                            math.random(-20, 20)
                        )
                        randomTorque.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                        
                        delay(5, function()
                            if randomForce and randomForce.Parent then
                                protectedCall(function() randomForce:Destroy() end)
                            end
                            if randomTorque and randomTorque.Parent then
                                protectedCall(function() randomTorque:Destroy() end)
                            end
                        end)
                    end)
                end
            end

            for _, obj in pairs(Workspace:GetDescendants()) do
                if obj:IsA("Part") and not obj.Anchored and not obj.Parent:FindFirstChild("Humanoid") and not obj.Parent:FindFirstChild("Head") and obj.Name ~= "Handle" then
                    ForcePart(obj)
                end
            end

            partDestroyerConnection = Workspace.DescendantAdded:Connect(function(descendant)
                if partDestroyerEnabled and descendant:IsA("Part") and not descendant.Anchored and 
                   not descendant.Parent:FindFirstChild("Humanoid") and 
                   not descendant.Parent:FindFirstChild("Head") and 
                   descendant.Name ~= "Handle" then
                    wait(0.1)
                    ForcePart(descendant)
                end
            end)
        else
            WindUI:Notify({
                Title = "已关闭零件崩飞",
                Content = "停止崩飞零件",
                Duration = 3
            })
            
            if partDestroyerConnection then
                partDestroyerConnection:Disconnect()
                partDestroyerConnection = nil
            end
        end
    end
})

Tab3:Toggle({
    Title = "自动胜出",
    Default = true,
    Callback = function(bool)
        _G.autowinfarm = bool
        while _G.autowinfarm do
            wait(.1)
            if _G.autowinfarm then
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-236, 180, 360, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            end
        end  
    end
})

Tab3:Toggle({
    Title = "地图玩家投票界面",
    Default = true,
    Callback = function(bool)
        if bool == false then 
            game.Players.LocalPlayer.PlayerGui.MainGui.MapVotePage.Visible = false
        end
        if bool == true then 
            game.Players.LocalPlayer.PlayerGui.MainGui.MapVotePage.Visible = true
        end
    end
})

Tab3:Toggle({
    Title = "水上行走",
    Default = true,
    Callback = function(bool)
        if bool == false then 
            game.Workspace.WaterLevel.CanCollide = false
            game.Workspace.WaterLevel.Size = Vector3.new(10, 1, 10)
        end
        if bool == true then 
            game.Workspace.WaterLevel.CanCollide = true
            game.Workspace.WaterLevel.Size = Vector3.new(5000, 1, 5000)
        end
    end
})

Tab3:Toggle({
    Title = "游戏岛悬崖碰撞",
    Default = true,
    Callback = function(bool)
        for i, v in pairs (game.workspace:GetDescendants()) do
            if v.Name == 'LowerRocks' then
                v.CanCollide = bool
            end
        end
    end
})

Tab3:Button({
    Title = "禁用跌落伤害",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        
        local hiddenfling = false
        local flingThread
        
        if not ReplicatedStorage:FindFirstChild("juisdfj0i32i0eidsuf0iok") then
            local detection = Instance.new("Decal")
            detection.Name = "juisdfj0i32i0eidsuf0iok"
            detection.Parent = ReplicatedStorage
        end
        
        local function fling()
            local lp = Players.LocalPlayer
            local c, hrp, vel, movel = nil, nil, nil, 0.1
        
            while hiddenfling do
                RunService.Heartbeat:Wait()
                c = lp.Character
                hrp = c and c:FindFirstChild("HumanoidRootPart")
        
                if hrp then
                    vel = hrp.Velocity
                    hrp.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
                    RunService.RenderStepped:Wait()
                    hrp.Velocity = vel
                    RunService.Stepped:Wait()
                    hrp.Velocity = vel + Vector3.new(0, movel, 0)
                    movel = -movel
                end
            end
        end
        
        hiddenfling = not hiddenfling
        
        if hiddenfling then
            flingThread = coroutine.create(fling)
            coroutine.resume(flingThread)
            WindUI:Notify({
                Title = "已开启防坠落伤害",
                Content = "推荐和FE-无敌少侠搭配",
                Duration = 3
            })
        else
            hiddenfling = false
            WindUI:Notify({
                Title = "无法关闭噢",
                Content = "我懒得搞开关",
                Duration = 3
            })
        end
    end
})

Tab3:Button({
    Title = "传送到地图",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-115.828506, 65.4863434, 18.8461514, 0.00697017973, 0.0789371505, -0.996855199, -3.13589936e-07, 0.996879458, 0.0789390653, 0.999975681, -0.000549906865, 0.00694845384)
    end
})

Tab3:Button({
    Title = "传送到游戏岛",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-83.5, 38.5, -27.5, -1, 0, 0, 0, 1, 0, 0, 0, -1)
    end
})

Tab3:Button({
    Title = "传送到产卵塔",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-280, 170, 341, 1, 0, 0, 0, 1, 0, 0, 0, 1)
    end
})

local Tab4 = Window:Tab({
    Title = "被遗弃",
    Icon = "drama",
    Locked = false,
})

Tab4:Button({
    Title = "FartSaken(汉化)",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/Chinese/refs/heads/main/Fartsaken%20Chinese"))()
    end
})

Tab4:Button({
    Title = "SntSaken(半汉化)",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/finendss/Chinese/refs/heads/main/SNTSaken"))()
    end
})

local HighlightSystem = {
    Settings = {
        ShowSurvivors = false,
        ShowKillers = false,
        Colors = {
            Survivor = Color3.fromRGB(0, 255, 255),
            Killer = Color3.fromRGB(255, 100, 100)
        },
        Transparency = {
            Fill = 0.9,
            Outline = 0
        }
    },
    Cache = {
        Highlights = {},
        Connections = {},
        Enabled = false
    }
}

local function CreateHighlight(char, isKiller)
    if not char or not char:FindFirstChild("Humanoid") then
        return nil
    end
    
    local highlight = Instance.new("Highlight")
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = isKiller and HighlightSystem.Settings.Colors.Killer or HighlightSystem.Settings.Colors.Survivor
    highlight.OutlineColor = highlight.FillColor
    highlight.FillTransparency = HighlightSystem.Settings.Transparency.Fill
    highlight.OutlineTransparency = HighlightSystem.Settings.Transparency.Outline
    highlight.Parent = char
    
    local conn = char.Humanoid.HealthChanged:Connect(function()
        if not char:FindFirstChild("Humanoid") then 
            conn:Disconnect() 
        end
    end)
    
    char.Humanoid.Died:Connect(function()
        highlight.OutlineTransparency = 1
        conn:Disconnect()
    end)
    
    return highlight
end

local function UpdateHighlights()
    for char, highlight in pairs(HighlightSystem.Cache.Highlights) do
        if not char.Parent then
            highlight:Destroy()
            HighlightSystem.Cache.Highlights[char] = nil
        end
    end
    
    if not HighlightSystem.Settings.ShowSurvivors and not HighlightSystem.Settings.ShowKillers then
        return
    end
    
    if HighlightSystem.Settings.ShowSurvivors then
        local survivors = workspace:FindFirstChild("Players")
        if survivors then
            survivors = survivors:FindFirstChild("Survivors")
            if survivors then
                for _, char in ipairs(survivors:GetDescendants()) do
                    if char:IsA("Model") and char:FindFirstChild("Humanoid") then
                        if not HighlightSystem.Cache.Highlights[char] then
                            HighlightSystem.Cache.Highlights[char] = CreateHighlight(char, false)
                        end
                    end
                end
            end
        end
    else
        for char, highlight in pairs(HighlightSystem.Cache.Highlights) do
            local isKiller = highlight.FillColor == HighlightSystem.Settings.Colors.Killer
            if not isKiller then
                highlight:Destroy()
                HighlightSystem.Cache.Highlights[char] = nil
            end
        end
    end
    
    if HighlightSystem.Settings.ShowKillers then
        local killers = workspace:FindFirstChild("Players")
        if killers then
            killers = killers:FindFirstChild("Killers")
            if killers then
                for _, char in ipairs(killers:GetDescendants()) do
                    if char:IsA("Model") and char:FindFirstChild("Humanoid") then
                        if not HighlightSystem.Cache.Highlights[char] then
                            HighlightSystem.Cache.Highlights[char] = CreateHighlight(char, true)
                        end
                    end
                end
            end
        end
    else
        for char, highlight in pairs(HighlightSystem.Cache.Highlights) do
            local isKiller = highlight.FillColor == HighlightSystem.Settings.Colors.Killer
            if isKiller then
                highlight:Destroy()
                HighlightSystem.Cache.Highlights[char] = nil
            end
        end
    end
end

local function ToggleHighlightSystem(enable)
    if enable then
        if not HighlightSystem.Cache.Connections["Main"] then
            HighlightSystem.Cache.Connections["Main"] = game:GetService("RunService").Heartbeat:Connect(UpdateHighlights)
        end
    else
        if HighlightSystem.Cache.Connections["Main"] then
            HighlightSystem.Cache.Connections["Main"]:Disconnect()
            HighlightSystem.Cache.Connections["Main"] = nil
        end
        
        for char, highlight in pairs(HighlightSystem.Cache.Highlights) do
            highlight:Destroy()
        end
        HighlightSystem.Cache.Highlights = {}
    end
end

Tab4:Toggle({
    Title = "绘制杀手",
    Default = false,
    Callback = function(state)
        HighlightSystem.Settings.ShowKillers = state
        
        if not HighlightSystem.Settings.ShowSurvivors and not state then
            ToggleHighlightSystem(false)
        else
            ToggleHighlightSystem(true)
            UpdateHighlights()
        end
    end
})

Tab4:Toggle({
    Title = "绘制幸存者",
    Locked = false,
    Callback = function(state)
        HighlightSystem.Settings.ShowSurvivors = state
        
        if not state and not HighlightSystem.Settings.ShowKillers then
            ToggleHighlightSystem(false)
        else
            ToggleHighlightSystem(true)
            UpdateHighlights()
        end
    end
})

Tab4:Toggle({
    Title = "绘制电机",
    Locked = false,
    Callback = function(enabled)
        if not _G.RealGeneratorESP then
            _G.RealGeneratorESP = {
                Active = false,
                Data = {},
                Connections = {}
            }
        end

        if not enabled then
            if _G.RealGeneratorESP.Active then
                for _, connection in pairs(_G.RealGeneratorESP.Connections) do
                    if connection and connection.Connected then
                        connection:Disconnect()
                    end
                end
                
                for gen, data in pairs(_G.RealGeneratorESP.Data) do
                    if type(data) == "table" then
                        if data.Billboard and data.Billboard.Parent then
                            data.Billboard:Destroy()
                        end
                        if data.DistanceBillboard and data.DistanceBillboard.Parent then
                            data.DistanceBillboard:Destroy()
                        end
                        if data.Highlight and data.Highlight.Parent then
                            data.Highlight:Destroy()
                        end
                    end
                end
                
                _G.RealGeneratorESP.Data = {}
                _G.RealGeneratorESP.Connections = {}
                _G.RealGeneratorESP.Active = false
            end
            return
        end

        if _G.RealGeneratorESP.Active then
            return
        end

        _G.RealGeneratorESP.Active = true

        local scanInterval = 1.0
        local lastScanTime = 0
        local maxGenerators = 20

        local distanceSettings = {
            MinDistance = 5,
            MaxDistance = 500,
            MinScale = 0.8,
            MaxScale = 1.5,
            MinTextSize = 8,
            MaxTextSize = 10
        }

        local function updateGeneratorESP(gen, data)
            if not gen or not gen.Parent or not gen:FindFirstChild("Main") then
                return false
            end
            
            if #_G.RealGeneratorESP.Data > maxGenerators then
                return false
            end
            
            if gen:FindFirstChild("Progress") then
                local progress = gen.Progress.Value
                if progress >= 99 then
                    return false
                end
                
                if data.TextLabel then
                    data.TextLabel.Text = string.format("真电机: %d%%", progress)
                end
                
                local character = game:GetService("Players").LocalPlayer.Character
                local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                
                if humanoidRootPart and data.DistanceLabel then
                    local distance = (gen.Main.Position - humanoidRootPart.Position).Magnitude
                    
                    data.DistanceLabel.Text = string.format("距离: %d米", math.floor(distance))
                    
                    local distanceRatio = math.clamp(
                        (distance - distanceSettings.MinDistance) / 
                        (distanceSettings.MaxDistance - distanceSettings.MinDistance),
                        0, 1
                    )
                    
                    local scale = distanceSettings.MinScale + 
                        distanceRatio * (distanceSettings.MaxScale - distanceSettings.MinScale)
                    
                    local textSize = distanceSettings.MinTextSize + 
                        distanceRatio * (distanceSettings.MaxTextSize - distanceSettings.MinTextSize)
                    
                    if data.Billboard then 
                        data.Billboard.Size = UDim2.new(4 * scale, 0, 1 * scale, 0)
                        data.Billboard.Enabled = true
                    end
                    
                    if data.DistanceBillboard then 
                        data.DistanceBillboard.Size = UDim2.new(4 * scale, 0, 1 * scale, 0)
                        data.DistanceBillboard.Enabled = true
                    end
                    
                    if data.TextLabel then 
                        data.TextLabel.TextSize = textSize
                        data.TextLabel.Visible = true
                    end
                    
                    if data.DistanceLabel then 
                        data.DistanceLabel.TextSize = textSize
                        data.DistanceLabel.Visible = true
                    end
                    
                    if data.Highlight then
                        data.Highlight.Enabled = true
                        local transparency = math.clamp((distance - 50) / 100, 0, 0.4)
                        data.Highlight.FillTransparency = 0.85 + (transparency * 0.5)
                        data.Highlight.OutlineColor = Color3.fromRGB(144, 238, 144)
                        data.Highlight.FillColor = Color3.fromRGB(144, 238, 144)
                    end
                end
            end
            
            return true
        end

        local function createGeneratorESP(gen)
            if not gen or not gen:FindFirstChild("Main") or _G.RealGeneratorESP.Data[gen] then 
                return 
            end
            
            if #_G.RealGeneratorESP.Data >= maxGenerators then
                return
            end
            
            local billboard = Instance.new("BillboardGui")
            billboard.Name = "RealGeneratorESP"
            billboard.Size = UDim2.new(4, 0, 1, 0)
            billboard.StudsOffset = Vector3.new(0, 2.5, 0)
            billboard.Adornee = gen.Main
            billboard.Parent = gen.Main
            billboard.AlwaysOnTop = true
            billboard.Enabled = true
            
            local textLabel = Instance.new("TextLabel")
            textLabel.Size = UDim2.new(1, 0, 0.5, 0)
            textLabel.BackgroundTransparency = 1
            textLabel.TextScaled = false
            textLabel.Text = "真电机加载中..."
            textLabel.TextColor3 = Color3.fromRGB(144, 238, 144)
            textLabel.Font = Enum.Font.Arcade
            textLabel.TextStrokeTransparency = 0
            textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            textLabel.TextSize = 8
            textLabel.Parent = billboard
            
            local distanceBillboard = Instance.new("BillboardGui")
            distanceBillboard.Name = "RealGeneratorDistanceESP"
            distanceBillboard.Size = UDim2.new(4, 0, 1, 0)
            distanceBillboard.StudsOffset = Vector3.new(0, 3.5, 0)
            distanceBillboard.Adornee = gen.Main
            distanceBillboard.Parent = gen.Main
            distanceBillboard.AlwaysOnTop = true
            distanceBillboard.Enabled = true
            
            local distanceLabel = Instance.new("TextLabel")
            distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
            distanceLabel.BackgroundTransparency = 1
            distanceLabel.TextScaled = false
            distanceLabel.Text = "计算距离中..."
            distanceLabel.TextColor3 = Color3.fromRGB(144, 238, 144)
            distanceLabel.Font = Enum.Font.Arcade
            distanceLabel.TextStrokeTransparency = 0
            distanceLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            distanceLabel.TextSize = 8
            distanceLabel.Parent = distanceBillboard
            
            local highlight = Instance.new("Highlight")
            highlight.Name = "RealGeneratorHighlight"
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.OutlineColor = Color3.fromRGB(144, 238, 144)
            highlight.FillColor = Color3.fromRGB(144, 238, 144)
            highlight.FillTransparency = 0.9
            highlight.OutlineTransparency = 0
            highlight.Parent = gen
            
            _G.RealGeneratorESP.Data[gen] = {
                Billboard = billboard,
                DistanceBillboard = distanceBillboard,
                TextLabel = textLabel,
                DistanceLabel = distanceLabel,
                Highlight = highlight
            }
            
            local destroyConnection
            destroyConnection = gen.Destroying:Connect(function()
                if _G.RealGeneratorESP.Data[gen] then
                    if _G.RealGeneratorESP.Data[gen].Billboard then 
                        _G.RealGeneratorESP.Data[gen].Billboard:Destroy() 
                    end
                    if _G.RealGeneratorESP.Data[gen].DistanceBillboard then 
                        _G.RealGeneratorESP.Data[gen].DistanceBillboard:Destroy() 
                    end
                    if _G.RealGeneratorESP.Data[gen].Highlight then 
                        _G.RealGeneratorESP.Data[gen].Highlight:Destroy() 
                    end
                    _G.RealGeneratorESP.Data[gen] = nil
                end
                if destroyConnection then
                    destroyConnection:Disconnect()
                end
            end)
            
            table.insert(_G.RealGeneratorESP.Connections, destroyConnection)
        end

        local function scanGenerators()
            local mapFolder = workspace:FindFirstChild("Map")
            if mapFolder then
                local ingameFolder = mapFolder:FindFirstChild("Ingame")
                if ingameFolder then
                    local mapSubFolder = ingameFolder:FindFirstChild("Map")
                    if mapSubFolder then
                        local generators = mapSubFolder:GetDescendants()
                        for _, gen in pairs(generators) do
                            if gen:IsA("Model") and gen:FindFirstChild("Main") and gen.Name == "Generator" then
                                createGeneratorESP(gen)
                            end
                        end
                    end
                end
            end
        end

        local mainConnection
        local mapFolder = workspace:FindFirstChild("Map")
        if mapFolder then
            local ingameFolder = mapFolder:FindFirstChild("Ingame")
            if ingameFolder then
                local mapSubFolder = ingameFolder:FindFirstChild("Map")
                if mapSubFolder then
                    mainConnection = mapSubFolder.DescendantAdded:Connect(function(v)
                        if v:IsA("Model") and v:FindFirstChild("Main") and v.Name == "Generator" then
                            createGeneratorESP(v)
                        end
                    end)
                end
            end
        end

        if mainConnection then
            table.insert(_G.RealGeneratorESP.Connections, mainConnection)
        end

        local heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
            lastScanTime = lastScanTime + deltaTime
            if lastScanTime >= scanInterval then
                lastScanTime = 0
                scanGenerators()
            end
            
            local gensToRemove = {}
            for gen, data in pairs(_G.RealGeneratorESP.Data) do
                if not gen or not gen.Parent then
                    table.insert(gensToRemove, gen)
                else
                    if not updateGeneratorESP(gen, data) then
                        table.insert(gensToRemove, gen)
                    end
                end
            end
            
            for _, gen in ipairs(gensToRemove) do
                if _G.RealGeneratorESP.Data[gen] then
                    if _G.RealGeneratorESP.Data[gen].Billboard then 
                        _G.RealGeneratorESP.Data[gen].Billboard:Destroy() 
                    end
                    if _G.RealGeneratorESP.Data[gen].DistanceBillboard then 
                        _G.RealGeneratorESP.Data[gen].DistanceBillboard:Destroy() 
                    end
                    if _G.RealGeneratorESP.Data[gen].Highlight then 
                        _G.RealGeneratorESP.Data[gen].Highlight:Destroy() 
                    end
                    _G.RealGeneratorESP.Data[gen] = nil
                end
            end
        end)

        table.insert(_G.RealGeneratorESP.Connections, heartbeatConnection)

        scanGenerators()
    end
})

local sprintModule
local isStaminaDrainDisabled = false
local staminaMonitorConnection = nil
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local function modifyStaminaSettings()
    pcall(function()
        if not sprintModule then
            local success, module = pcall(require, ReplicatedStorage.Systems.Character.Game.Sprinting)
            if success and module then
                sprintModule = module
                return
            end
        end
        if sprintModule and sprintModule.StaminaLossDisabled ~= nil then
             sprintModule.StaminaLossDisabled = isStaminaDrainDisabled
        end
    end)
end

local function monitorAndReapplyStamina()
    if staminaMonitorConnection then
        staminaMonitorConnection:Disconnect()
    end
    staminaMonitorConnection = RunService.Heartbeat:Connect(function()
        if isStaminaDrainDisabled then
            modifyStaminaSettings()
        else
            if staminaMonitorConnection then
                staminaMonitorConnection:Disconnect()
                staminaMonitorConnection = nil
            end
        end
    end)
end

Tab4:Toggle({
    Title = "无限体力",
    Default = false,
    Callback = function(state)
        isStaminaDrainDisabled = state
        modifyStaminaSettings()
        
        if state then
            monitorAndReapplyStamina()
        else
            if staminaMonitorConnection then
                staminaMonitorConnection:Disconnect()
                staminaMonitorConnection = nil
            end
            if sprintModule and sprintModule.StaminaLossDisabled ~= nil then
                sprintModule.StaminaLossDisabled = false 
            end
        end
    end
})

local FINNB = {
    Enabled = false,
    BaseDistance = 16,
    ScanInterval = 0.001,
    BlockCooldown = 0.08,
    MoveCompBase = 1.5,
    MoveCompFactor = 0.25,
    SpeedThreshold = 8,
    PredictBase = 4,
    PredictMax = 12,
    PredictFactor = 0.35,
    TargetAngle = 50,
    MinAttackSpeed = 12,
    ShowVisualization = false,
    EnablePrediction = false,
    PingCompensation = 0.1,
    FastKillerAdjust = 1.3,
    TargetSoundIds = {
        "102228729296384", "140242176732868", "112809109188560", "136323728355613",
        "115026634746636", "84116622032112", "108907358619313", "127793641088496",
        "86174610237192", "95079963655241", "101199185291628", "119942598489800",
        "84307400688050", "113037804008732", "105200830849301", "75330693422988",
        "82221759983649", "81702359653578", "108610718831698", "112395455254818",
        "109431876587852", "109348678063422", "85853080745515", "12222216"
    }
}

pcall(function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local Stats = game:GetService("Stats")
    
    local soundLookup = {}
    for _, id in ipairs(FINNB.TargetSoundIds) do
        soundLookup[id] = true
        soundLookup["rbxassetid://" .. id] = true
    end
    
    local LocalPlayer = Players.LocalPlayer
    local lastBlockTime = 0
    local combatConnection = nil
    local lastScanTime = 0
    local visualizationParts = {}
    local soundCache = {}
    local lastSoundCheck = 0
    local lastPingCheck = 0
    local currentPing = 0
    
    local function GetPing()
        local currentTime = os.clock()
        if currentTime - lastPingCheck < 0.5 then
            return currentPing
        end
        lastPingCheck = currentTime
        
        local stats = Stats and Stats.Network and Stats.Network:FindFirstChild("ServerStatsItem")
        if stats then
            local pingStat = stats:FindFirstChild("Data Ping")
            if pingStat then
                currentPing = pingStat.Value
                return currentPing
            end
        end
        
        return 0
    end
    
    local function GetPingCompensation()
        local ping = GetPing()
        return math.min(0.3, ping / 1000 * FINNB.PingCompensation * 10)
    end
    
    local function CreateVisualization()
        if not LocalPlayer.Character then return end
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        for _, part in ipairs(visualizationParts) do
            part:Destroy()
        end
        visualizationParts = {}
        
        local center = rootPart.Position
        local distance = FINNB.BaseDistance
        local angle = math.rad(FINNB.TargetAngle)
        local segments = 36
        
        local basePart = Instance.new("Part")
        basePart.Size = Vector3.new(0.1, 0.1, 0.1)
        basePart.Position = center + Vector3.new(0, 0.1, 0)
        basePart.Anchored = true
        basePart.CanCollide = false
        basePart.Transparency = 1
        basePart.Parent = workspace
        table.insert(visualizationParts, basePart)
        
        for i = 1, segments do
            local part = Instance.new("Part")
            part.Size = Vector3.new(0.5, 0.1, 0.5)
            part.BrickColor = BrickColor.new("Bright green")
            part.Material = Enum.Material.Neon
            part.Transparency = 0.7
            part.Anchored = true
            part.CanCollide = false
            part.Parent = workspace
            table.insert(visualizationParts, part)
        end
        
        local function UpdateVisualization()
            if not FINNB.ShowVisualization then return end
            if not LocalPlayer.Character then return end
            local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not root then return end
            
            local center = root.Position + Vector3.new(0, 0.1, 0)
            local lookVector = root.CFrame.LookVector
            local distance = FINNB.BaseDistance
            local angle = math.rad(FINNB.TargetAngle)
            
            basePart.Position = center
            
            for i = 1, #visualizationParts - 1 do
                local part = visualizationParts[i + 1]
                local segmentAngle = (i - 1) * (2 * angle) / (#visualizationParts - 2) - angle
                local rotCFrame = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), segmentAngle)
                local dir = rotCFrame:VectorToWorldSpace(lookVector)
                local pos = center + dir * distance
                part.Position = pos
                part.Size = Vector3.new(0.5, 0.1, 0.5)
            end
        end
        
        local visConnection
        visConnection = RunService.Heartbeat:Connect(function()
            if not FINNB.ShowVisualization then
                for _, part in ipairs(visualizationParts) do
                    part:Destroy()
                end
                visualizationParts = {}
                visConnection:Disconnect()
                return
            end
            pcall(UpdateVisualization)
        end)
    end
    
    local function HasTargetSound(character)
        if not character then return false end
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return false end
        
        local currentTime = os.clock()
        if currentTime - lastSoundCheck < 0.0005 then
            return soundCache[character] or false
        end
        lastSoundCheck = currentTime
        
        local found = false
        for _, child in ipairs(rootPart:GetChildren()) do
            if child:IsA("Sound") then
                local soundId = tostring(child.SoundId)
                local numericId = string.match(soundId, "(%d+)$")
                if numericId and soundLookup[numericId] then
                    found = true
                    break
                end
            end
        end
        
        soundCache[character] = found
        return found
    end
    
    local function GetMoveCompensation()
        if not LocalPlayer.Character then return 0 end
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return 0 end
        
        local velocity = rootPart.Velocity
        local speed = math.sqrt(velocity.X^2 + velocity.Y^2 + velocity.Z^2)
        return FINNB.MoveCompBase + (speed * FINNB.MoveCompFactor)
    end
    
    local function IsFastKiller(killer)
        if not killer then return false end
        local killerRoot = killer:FindFirstChild("HumanoidRootPart")
        if not killerRoot then return false end
        
        local killerVel = killerRoot.Velocity
        local killerSpeed = math.sqrt(killerVel.X^2 + killerVel.Y^2 + killerVel.Z^2)
        return killerSpeed > FINNB.MinAttackSpeed
    end
    
    local function GetTotalDetectionRange(killer)
        local base = FINNB.BaseDistance
        local moveBonus = GetMoveCompensation()
        local predict = 0
        local pingBonus = GetPingCompensation() * 5
        
        if FINNB.EnablePrediction and killer and killer:FindFirstChild("HumanoidRootPart") then
            local killerVel = killer.HumanoidRootPart.Velocity
            local killerSpeed = math.sqrt(killerVel.X^2 + killerVel.Y^2 + killerVel.Z^2)
            
            if killerSpeed > FINNB.SpeedThreshold then
                predict = math.min(
                    FINNB.PredictMax, 
                    FINNB.PredictBase + (killerSpeed * FINNB.PredictFactor)
                )
            end
            
            if IsFastKiller(killer) then
                predict = predict * FINNB.FastKillerAdjust
            end
        end
        
        return base + moveBonus + predict + pingBonus
    end
    
    local function IsTargetingMe(killer)
        local myCharacter = LocalPlayer.Character
        if not myCharacter then return false end
        
        local myRoot = myCharacter:FindFirstChild("HumanoidRootPart")
        local killerRoot = killer and killer:FindFirstChild("HumanoidRootPart")
        if not myRoot or not killerRoot then return false end
        
        local directionToMe = (myRoot.Position - killerRoot.Position).Unit
        local killerLook = killerRoot.CFrame.LookVector
        
        local dot = directionToMe:Dot(killerLook)
        local angle = math.deg(math.acos(math.clamp(dot, -1, 1)))
        
        return angle <= FINNB.TargetAngle
    end
    
    local function GetThreateningKillers()
        local killers = {}
        local killersFolder = workspace:FindFirstChild("Killers") or (workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers"))
        if not killersFolder then return killers end
        
        local myCharacter = LocalPlayer.Character
        if not myCharacter then return killers end
        
        local myRoot = myCharacter:FindFirstChild("HumanoidRootPart")
        if not myRoot then return killers end
        
        for _, killer in ipairs(killersFolder:GetChildren()) do
            if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
                local killerRoot = killer.HumanoidRootPart
                local distance = (myRoot.Position - killerRoot.Position).Magnitude
                local detectionRange = GetTotalDetectionRange(killer)
                
                if distance <= detectionRange and HasTargetSound(killer) and IsTargetingMe(killer) then
                    table.insert(killers, killer)
                end
            end
        end
        
        return killers
    end
    
    local function GetAdjustedCooldown()
        local ping = GetPing()
        return math.max(0.05, FINNB.BlockCooldown - (ping / 1000 * 0.5))
    end
    
    local function PerformBlock()
        local now = os.clock()
        if now - lastBlockTime >= GetAdjustedCooldown() then
            pcall(function()
                local args = {
                    "UseActorAbility",
                    {
                        buffer.fromstring("\"Block\"")
                    }
                }
                game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
                lastBlockTime = now
            end)
        end
    end
    
    local function CombatLoop()
        local currentTime = os.clock()
        if currentTime - lastScanTime >= FINNB.ScanInterval then
            lastScanTime = currentTime
            local killers = GetThreateningKillers()
            if #killers > 0 then
                PerformBlock()
            end
        end
    end
    
    Tab4:Toggle({
        Title = "自动格挡",
        Default = true,
        Callback = function(enabled)
            FINNB.Enabled = enabled
            if enabled then
                if combatConnection then
                    combatConnection:Disconnect()
                end
                combatConnection = RunService.Stepped:Connect(function()
                    pcall(CombatLoop)
                end)
            elseif combatConnection then
                combatConnection:Disconnect()
                combatConnection = nil
            end
        end
    })
    
    Tab4:Slider({
        Title = "格挡距离",
        Value = {
            Min = 5,
            Max = 30,
            Default = 16,
        },
        Increment = 1,
        Callback = function(value)
            FINNB.BaseDistance = value
        end
    })
    
    Tab4:Slider({
        Title = "格挡角度",
        Value = {
            Min = 10,
            Max = 180,
            Default = 70,
        },
        Increment = 1,
        Callback = function(value)
            FINNB.TargetAngle = value
        end
    })
           
    Tab4:Toggle({
        Title = "可视化",
        Default = true,
        Callback = function(enabled)
            FINNB.ShowVisualization = enabled
            if enabled then
                CreateVisualization()
            else
                for _, part in ipairs(visualizationParts) do
                    part:Destroy()
                end
                visualizationParts = {}
            end
        end
    })
    
    LocalPlayer.CharacterAdded:Connect(function()
        if FINNB.Enabled and combatConnection then
            combatConnection:Disconnect()
            combatConnection = RunService.Stepped:Connect(CombatLoop)
        end
        if FINNB.ShowVisualization then
            CreateVisualization()
        end
    end)
end)

local Tab6 = Window:Tab({
    Title = "最强战场",
    Icon = "drama",
    Locked = false,
})

Tab6:Section({Title = "主要", TextXAlignment = "Left", TextSize = 17})

local autoTpToPlayer = false
local tpLoop = nil

local function getClosestPlayer()
    local me = Players.LocalPlayer
    local myChar = me.Character
    if not myChar then return nil end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    
    local closest = nil
    local closestDist = math.huge
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= me then
            local char = player.Character
            if char then
                local root = char:FindFirstChild("HumanoidRootPart")
                if root then
                    local dist = (myRoot.Position - root.Position).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        closest = player
                    end
                end
            end
        end
    end
    
    return closest, closestDist
end

local function teleportToPlayerBack()
    if not autoTpToPlayer then return end
    
    local myChar = Players.LocalPlayer.Character
    if not myChar then return end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    local targetPlayer, distance = getClosestPlayer()
    if not targetPlayer then return end
    
    local targetChar = targetPlayer.Character
    if not targetChar then return end
    
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    
    local targetCFrame = targetRoot.CFrame
    local behindOffset = targetCFrame.LookVector * -2
    local targetPosition = targetRoot.Position + behindOffset
    
    myRoot.CFrame = CFrame.new(targetPosition)
end

local function startAutoTeleport()
    if tpLoop then
        tpLoop:Disconnect()
    end
    
    tpLoop = RunService.Heartbeat:Connect(function()
        if autoTpToPlayer then
            teleportToPlayerBack()
        end
    end)
end

local function stopAutoTeleport()
    if tpLoop then
        tpLoop:Disconnect()
        tpLoop = nil
    end
end

Tab6:Toggle({
    Title = "自动锁敌",
    Default = false,
    Callback = function(state)
        autoTpToPlayer = state
        if state then
            startAutoTeleport()
            WindUI:Notify({
                Title = "自动锁敌已开启",
                Content = "打死别人👅👅",
                Duration = 3
            })
        else
            stopAutoTeleport()
            WindUI:Notify({
                Title = "自动锁敌已关闭",
                Content = "休息会",
                Duration = 3
            })
        end
    end
})

Players.LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(2)
    if autoTpToPlayer then
        startAutoTeleport()
    end
end)

local defenseOn = false
local faceOn = false
local attackOn = false
local defenseDistance = 30
local faceDistance = 5000
local attackDistance = 10
local animId = "10470389827"
local animTrack = nil
local defenseLoop = nil
local faceLoop = nil
local attackLoop = nil

local function setupAnim()
    local char = Players.LocalPlayer.Character
    if char and char:FindFirstChild("Humanoid") then
        local humanoid = char:FindFirstChild("Humanoid")
        local newAnim = Instance.new("Animation")
        newAnim.AnimationId = "rbxassetid://" .. animId
        animTrack = humanoid:LoadAnimation(newAnim)
        return true
    end
    return false
end

local function startAnim()
    if animTrack and not animTrack.IsPlaying then
        animTrack:Play()
    end
end

local function stopAnim()
    if animTrack and animTrack.IsPlaying then
        animTrack:Stop()
    end
end

local function playersInAttackRange()
    local me = Players.LocalPlayer
    local myChar = me.Character
    if not myChar then return false end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return false end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= me then
            local char = player.Character
            if char then
                local root = char:FindFirstChild("HumanoidRootPart")
                if root then
                    local dist = (myRoot.Position - root.Position).Magnitude
                    if dist <= attackDistance then
                        return true
                    end
                end
            end
        end
    end
    
    return false
end

local function performAttack()
    local args = {
        {
            Goal = "LeftClick",
            Mobile = true
        }
    }
    local char = Players.LocalPlayer.Character
    if char and char:FindFirstChild("Communicate") then
        char.Communicate:FireServer(unpack(args))
    end
end

local function playersClose()
    local me = Players.LocalPlayer
    local myChar = me.Character
    if not myChar then return false end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return false end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= me then
            local char = player.Character
            if char then
                local root = char:FindFirstChild("HumanoidRootPart")
                if root then
                    local dist = (myRoot.Position - root.Position).Magnitude
                    if dist <= defenseDistance then
                        return true
                    end
                end
            end
        end
    end
    
    return false
end

local function getClosestPlayerForFace()
    local me = Players.LocalPlayer
    local myChar = me.Character
    if not myChar then return nil end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    
    local closest = nil
    local closestDist = 9999
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= me then
            local char = player.Character
            if char then
                local root = char:FindFirstChild("HumanoidRootPart")
                if root then
                    local dist = (myRoot.Position - root.Position).Magnitude
                    if dist < closestDist and dist <= faceDistance then
                        closestDist = dist
                        closest = player
                    end
                end
            end
        end
    end
    
    return closest
end

local function turnToPlayer()
    if not faceOn then return end
    
    local myChar = Players.LocalPlayer.Character
    if not myChar then return end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    local targetPlayer = getClosestPlayerForFace()
    if not targetPlayer then return end
    
    local targetChar = targetPlayer.Character
    if not targetChar then return end
    
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    
    local dir = (targetRoot.Position - myRoot.Position).Unit
    local lookDir = Vector3.new(dir.X, 0, dir.Z)
    
    if lookDir.Magnitude > 0 then
        myRoot.CFrame = CFrame.new(myRoot.Position, myRoot.Position + lookDir)
    end
end

local function beginAttackSystem()
    if attackLoop then
        attackLoop:Disconnect()
    end
    
    attackLoop = RunService.Heartbeat:Connect(function()
        if attackOn then
            local inRange = playersInAttackRange()
            if inRange then
                performAttack()
            end
        end
    end)
end

local function endAttackSystem()
    if attackLoop then
        attackLoop:Disconnect()
        attackLoop = nil
    end
end

local function beginFaceSystem()
    if faceLoop then
        faceLoop:Disconnect()
    end
    
    faceLoop = RunService.Heartbeat:Connect(function()
        if faceOn then
            turnToPlayer()
        end
    end)
end

local function endFaceSystem()
    if faceLoop then
        faceLoop:Disconnect()
        faceLoop = nil
    end
end

local function beginDefenseSystem()
    if defenseLoop then
        defenseLoop:Disconnect()
    end
    
    if not setupAnim() then
        return false
    end
    
    defenseLoop = RunService.Heartbeat:Connect(function()
        if defenseOn and animTrack then
            local nearby = playersClose()
            if nearby then
                startAnim()
            else
                stopAnim()
            end
        end
    end)
    return true
end

local function endDefenseSystem()
    if defenseLoop then
        defenseLoop:Disconnect()
        defenseLoop = nil
    end
    stopAnim()
end

Players.LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(2)
    if defenseOn then
        setupAnim()
    end
    if attackOn then
        beginAttackSystem()
    end
end)

Tab6:Toggle({
    Title = "靠近自动假防御",
    Default = false,
    Callback = function(state)
        defenseOn = state
        if state then
            beginDefenseSystem()
        else
            endDefenseSystem()
        end
    end
})

Tab6:Toggle({
    Title = "朝向玩家",
    Default = false,
    Callback = function(state)
        faceOn = state
        if state then
            beginFaceSystem()
        else
            endFaceSystem()
        end
    end
})

Tab6:Toggle({
    Title = "自动平A",
    Default = false,
    Callback = function(state)
        attackOn = state
        if state then
            beginAttackSystem()
        else
            endAttackSystem()
        end
    end
})

Tab6:Toggle({
    Title = "自动拾取垃圾桶",
    Default = false,
    Callback = function(state)
        AUTO_TRASH_MASTER = state

        if state then
            task.spawn(
                function()
                    local Players = game:GetService("Players")
                    local Workspace = game:GetService("Workspace")
                    local RunService = game:GetService("RunService")
                    local TRASH_RANGE = 15
                    local PLAYER_RANGE = 100
                    local PICKUP_DISTANCE = 2
                    local ATTACK_DISTANCE = 2
                    local HEIGHT_OFFSET = 3
                    local localPlayer = Players.LocalPlayer
                    local character, rootPart, humanoid

                    local function updateCharacter()
                        character = localPlayer.Character
                        if character then
                            rootPart = character:FindFirstChild("HumanoidRootPart")
                            humanoid = character:FindFirstChildOfClass("Humanoid")
                        else
                            rootPart = nil
                            humanoid = nil
                        end
                    end

                    updateCharacter()
                    localPlayer.CharacterAdded:Connect(updateCharacter)

                    local function getTrashPart(trashModel)
                        return trashModel:FindFirstChild("Handle") or trashModel:FindFirstChild("MainPart") or trashModel:FindFirstChild("TrashCan") or trashModel.PrimaryPart or trashModel:FindFirstChildWhichIsA("BasePart")
                    end

                    local function performAction(action)
                        if AUTO_TRASH_MASTER and character then
                            local communicate = character:FindFirstChild("Communicate")
                            if communicate then
                                communicate:FireServer({["Goal"] = action})
                            end
                        end
                    end

                    local function calculateOffsetPosition(targetPos, referencePos)
                        local direction = (targetPos - referencePos).Unit
                        direction = Vector3.new(direction.X, 0, direction.Z).Unit

                        if direction.Magnitude < 0.1 then
                            direction = Vector3.new(math.random(), 0, math.random()).Unit
                        end

                        return targetPos + (direction * PICKUP_DISTANCE)
                    end

                    local function calculateBehindPosition(targetRoot)
                        local lookVector = targetRoot.CFrame.LookVector
                        lookVector = Vector3.new(lookVector.X, 0, lookVector.Z).Unit

                        return targetRoot.Position - (lookVector * ATTACK_DISTANCE)
                    end

                    local function findNearestPlayer()
                        if not rootPart then
                            return nil, nil
                        end

                        local nearestPlayer = nil
                        local nearestDistance = math.huge
                        local targetPosition = nil

                        for _, targetPlayer in ipairs(Players:GetPlayers()) do
                            if targetPlayer ~= localPlayer and targetPlayer.Character then
                                local targetChar = targetPlayer.Character
                                local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
                                local targetHum = targetChar:FindFirstChildOfClass("Humanoid")

                                if targetRoot and targetHum and targetHum.Health > 0 then
                                    local distance = (rootPart.Position - targetRoot.Position).Magnitude
                                    if distance <= PLAYER_RANGE and distance < nearestDistance then
                                        nearestDistance = distance
                                        nearestPlayer = targetPlayer
                                        targetPosition = calculateBehindPosition(targetRoot)
                                    end
                                end
                            end
                        end

                        return nearestPlayer, targetPosition
                    end

                    local function teleportTo(position, faceTarget)
                        if rootPart and AUTO_TRASH_MASTER then
                            local raycastParams = RaycastParams.new()
                            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                            raycastParams.FilterDescendantsInstances = {character}

                            local groundPosition = position
                            local ray = Workspace:Raycast(position + Vector3.new(0, 10, 0), Vector3.new(0, -20, 0), raycastParams)
                            if ray and ray.Position then
                                groundPosition = ray.Position + Vector3.new(0, HEIGHT_OFFSET, 0)
                            else
                                groundPosition = position + Vector3.new(0, HEIGHT_OFFSET, 0)
                            end

                            if faceTarget then
                                local lookVector = (faceTarget - groundPosition).Unit
                                rootPart.CFrame = CFrame.new(groundPosition, groundPosition + lookVector)
                            else
                                rootPart.CFrame = CFrame.new(groundPosition)
                            end
                        end
                    end

                    while AUTO_TRASH_MASTER and game:GetService("RunService").Heartbeat:Wait() do
                        pcall(
                            function()
                                updateCharacter()
                                if not character or not rootPart or not humanoid or humanoid.Health <= 0 then
                                    task.wait(1)
                                    return
                                end

                                if not character:GetAttribute("HasTrashcan") then
                                    local trashFolder = Workspace:FindFirstChild("Trash") or (Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Trash"))

                                    if not trashFolder then
                                        task.wait(1)
                                        return
                                    end

                                    local nearestTrash, nearestDistance, trashPosition
                                    for _, trashModel in ipairs(trashFolder:GetChildren()) do
                                        if trashModel:IsA("Model") then
                                            local trashPart = getTrashPart(trashModel)
                                            if trashPart then
                                                local distance = (rootPart.Position - trashPart.Position).Magnitude
                                                if distance <= TRASH_RANGE and (not nearestDistance or distance < nearestDistance) then
                                                    nearestTrash = trashModel
                                                    nearestDistance = distance
                                                    trashPosition = trashPart.Position
                                                end
                                            end
                                        end
                                    end

                                    if nearestTrash and trashPosition then
                                        local offsetPosition = calculateOffsetPosition(trashPosition, rootPart.Position)

                                        teleportTo(offsetPosition, trashPosition)
                                        task.wait(0.2)

                                        local direction = (trashPosition - rootPart.Position).Unit
                                        local lookVector = Vector3.new(direction.X, 0, direction.Z).Unit
                                        if lookVector.Magnitude > 0.1 then
                                            rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + lookVector)
                                        end

                                        performAction("LeftClick")
                                        task.wait(0.15)
                                        performAction("LeftClickRelease")

                                        local waitTime = 0
                                        while waitTime < 2 and AUTO_TRASH_MASTER do
                                            if character:GetAttribute("HasTrashcan") then
                                                break
                                            end
                                            task.wait(0.1)
                                            waitTime = waitTime + 0.1
                                        end
                                    else
                                        task.wait(1)
                                    end
                                else
                                    local nearestPlayer, behindPos = findNearestPlayer()

                                    if nearestPlayer and behindPos then
                                        local targetChar = nearestPlayer.Character
                                        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")

                                        if not targetRoot then
                                            task.wait(0.5)
                                            return
                                        end

                                        teleportTo(behindPos, targetRoot.Position)
                                        task.wait(0.2)

                                        local direction = (targetRoot.Position - rootPart.Position).Unit
                                        local lookVector = Vector3.new(direction.X, 0, direction.Z).Unit
                                        if lookVector.Magnitude > 0.1 then
                                            rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + lookVector)
                                        end

                                        performAction("LeftClick")
                                        task.wait(0.1)
                                        performAction("LeftClickRelease")

                                        task.wait(1.5)
                                    else
                                        task.wait(1)
                                    end
                                end
                            end
                        )
                    end
                end
            )
        end
    end
})

Tab6:Section({Title = "传送", TextXAlignment = "Left", TextSize = 17})

Tab6:Button({
    Title = "传送到墙上",
    Callback = function()
    game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(253.515198, 699.103455, 420.533813)
    end
})

Tab6:Button({
    Title = "传送到地图",
    Callback = function()
    game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(63.4928513, 440.505829, -92.9229507)
    end
})

local TPYW

Tab6:Button({
    Title = "设置原位",
    Callback = function()
    TPYW = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame
    end
})

Tab6:Button({
    Title = "传送到原位",
    Callback = function()
    if TPYW then
        game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = TPYW
    end
    end
})

local Tab5 = Window:Tab({
    Title = "死亡之死",
    Icon = "drama",
    Locked = false,
})

Tab5:Paragraph({
    Title = "请在专属服务器中使用",
    Desc = "死亡之死",
    Color = "Blue"
})

local LocalPlayer = game.Players.LocalPlayer
local Character, Char
local HumanoidRootPart, HRP
local Humanoid, Hum
local NoStaminaLoss = false
local NoFatigue = false

pcall(function()
    Character, Char = LocalPlayer.Character, LocalPlayer.Character
end)
pcall(function()
    HumanoidRootPart, HRP = Character.HumanoidRootPart, Character.HumanoidRootPart
end)
pcall(function()
    Humanoid, Hum = Character.Humanoid, Character.Humanoid
end)

LocalPlayer.CharacterAdded:Connect(function()
    pcall(function()
        Character, Char = nil, nil
        HumanoidRootPart, HRP = nil, nil
        Humanoid, Hum = nil, nil
        task.wait()
        repeat task.wait() until LocalPlayer.Character
        Character, Char = LocalPlayer.Character, LocalPlayer.Character
        task.wait()
        repeat task.wait() until Character:FindFirstChild("HumanoidRootPart")
        HumanoidRootPart, HRP = Character.HumanoidRootPart, Character.HumanoidRootPart
        task.wait()
        repeat task.wait() until Character:FindFirstChild("Humanoid")
        Humanoid, Hum = Character.Humanoid, Character.Humanoid
    end)
end)

local StaminaModule
pcall(function()
    StaminaModule = require(LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGui"):WaitForChild("Client"):WaitForChild("Modules"):WaitForChild("Movement"))
end)

function SetStaminaProperty(property, value)
    if property == "MaxStamina" then
        Char:SetAttribute("MaxStamina", value)
    elseif property == "Stamina" then
        if StaminaModule then
            StaminaModule["Stamina"] = value
        end
    elseif property == "Fatigue" then
        Char:SetAttribute("Fatigue", value)
    elseif property == "WalkSpeed" then
        Hum.WalkSpeed = value
    elseif property == "SprintSpeed" then
        Char:SetAttribute("SprintSpeed", value)
    elseif property == "CanJump" then
        if value == true then 
            Hum.JumpPower = 50 
        else 
            Hum.JumpPower = 0 
        end
    end
end

local killerHighlights = {}
local survivorHighlights = {}
local killerConnection, killerRemovedConnection
local survivorConnection, survivorRemovedConnection

local function cleanupHighlights(highlightsTable)
    for target, highlight in pairs(highlightsTable) do
        if highlight and typeof(highlight) == "Instance" and highlight:IsA("Highlight") then
            highlight:Destroy()
        end
    end
    return {}
end

local function createHighlight(target, color)
    local humanoid = target:FindFirstChildOfClass("Humanoid")
    local rootPart = target:FindFirstChild("HumanoidRootPart") or target:FindFirstChild("Torso")
    
    if humanoid and rootPart then
        local highlight = Instance.new("Highlight")
        highlight.FillColor = color
        highlight.FillTransparency = 0.65
        highlight.OutlineColor = Color3.new(1, 1, 1)
        highlight.OutlineTransparency = 0
        highlight.Adornee = target
        highlight.Parent = target
        return highlight
    end
    return nil
end

local function initializeTeamHighlights(teamFolder, highlightsTable, color)
    if not teamFolder then
        warn("Team folder not found: " .. tostring(teamFolder))
        return
    end
    
    for _, member in teamFolder:GetChildren() do
        if member:IsA("Model") then
            local highlight = createHighlight(member, color)
            if highlight then
                highlightsTable[member] = highlight
            end
        end
    end
    
    local connection = teamFolder.ChildAdded:Connect(function(child)
        if child:IsA("Model") then
            task.wait(0.5)
            local highlight = createHighlight(child, color)
            if highlight then
                highlightsTable[child] = highlight
            end
        end
    end)
    
    local removedConnection = teamFolder.ChildRemoved:Connect(function(child)
        if highlightsTable[child] then
            if highlightsTable[child] and typeof(highlightsTable[child]) == "Instance" then
                highlightsTable[child]:Destroy()
            end
            highlightsTable[child] = nil
        end
    end)
    
    return connection, removedConnection
end

local killerEnabled = true
local survivorEnabled = true

Tab5:Toggle({
    Title = "绘制杀手",
    Default = true,
    Callback = function(Value)
        local killerTeam = workspace.GameAssets.Teams.Killer
        
        if Value then
            WindUI:Notify({
                Title = "绘制杀手开启",
                Content = "你看到见了👁️",
                Duration = 3
            })
            
            killerConnection, killerRemovedConnection = initializeTeamHighlights(
                killerTeam, 
                killerHighlights, 
                Color3.new(1, 0, 0)
            )
            
            killerEnabled = true
        else
            WindUI:Notify({
                Title = "绘制杀手已关闭",
                Content = "你看不见了😭",
                Duration = 3
            })
            
            if killerConnection then
                killerConnection:Disconnect()
                killerConnection = nil
            end
            if killerRemovedConnection then
                killerRemovedConnection:Disconnect()
                killerRemovedConnection = nil
            end
            
            for target, highlight in pairs(killerHighlights) do
                if highlight and typeof(highlight) == "Instance" and highlight:IsA("Highlight") then
                    highlight:Destroy()
                end
            end
            killerHighlights = {}
            
            killerEnabled = false
        end
    end
})

Tab5:Toggle({
    Title = "绘制幸存者",
    Default = true,
    Callback = function(Value)
        local survivorTeam = workspace.GameAssets.Teams.Survivor
        
        if Value then
            WindUI:Notify({
                Title = "绘制幸存者开启",
                Content = "队友队友😍",
                Duration = 3
            })
            
            survivorConnection, survivorRemovedConnection = initializeTeamHighlights(
                survivorTeam, 
                survivorHighlights, 
                Color3.new(0, 0, 1)
            )
            
            survivorEnabled = true
        else
            WindUI:Notify({
                Title = "绘制幸存者关闭",
                Content = "队友呢😭",
                Duration = 3
            })
            
            if survivorConnection then
                survivorConnection:Disconnect()
                survivorConnection = nil
            end
            if survivorRemovedConnection then
                survivorRemovedConnection:Disconnect()
                survivorRemovedConnection = nil
            end
            
            for target, highlight in pairs(survivorHighlights) do
                if highlight and typeof(highlight) == "Instance" and highlight:IsA("Highlight") then
                    highlight:Destroy()
                end
            end
            survivorHighlights = {}
            
            survivorEnabled = false
        end
    end
})

Tab5:Toggle({
    Title = "无视杀手墙",
    Default = false,
    Callback = function(state)
        local killerOnlyFolder = game:GetService("Workspace"):FindFirstChild("GameAssets"):FindFirstChild("Map"):FindFirstChild("Config"):FindFirstChild("KillerOnly")
        if killerOnlyFolder then
            for _, part in pairs(killerOnlyFolder:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = not state
                end
            end
            if state then
                WindUI:Notify({
                    Title = "无视已开启",
                    Content = "杀手墙碰撞已关闭",
                    Duration = 3
                })
            else
                WindUI:Notify({
                    Title = "无视已关闭",
                    Content = "不能过去了 555",
                    Duration = 3
                })
            end
        else
            WindUI:Notify({
                Title = "无视已开启",
                Content = "随便过杀手专用墙",
                Duration = 3
            })
        end
    end
})

Tab5:Button({
    Title = "无限体力",
    Callback = function()
        SetStaminaProperty("MaxStamina", math.huge)
        SetStaminaProperty("Stamina", math.huge)
        WindUI:Notify({
            Title = "无限体力已启用",
            Content = "体力已无限",
            Duration = 3
        })
    end
})

Tab5:Button({
    Title = "启用/禁用跳跃",
    Callback = function()
        if Humanoid then
            if Humanoid.JumpPower == 0 then
                SetStaminaProperty("CanJump", true)
                WindUI:Notify({
                    Title = "跳跃已启用",
                    Content = "跳跃已恢复",
                    Duration = 3
                })
            else
                SetStaminaProperty("CanJump", false)
                WindUI:Notify({
                    Title = "跳跃已禁用",
                    Content = "跳跃已关闭",
                    Duration = 3
                })
            end
        end
    end
})

Tab5:Toggle({
    Title = "无体力消耗",
    Default = false,
    Callback = function(Value)
        NoStaminaLoss = Value
        if NoStaminaLoss then
            WindUI:Notify({
                Title = "无体力消耗已开启",
                Content = "体力将不会减少",
                Duration = 3
            })
            while NoStaminaLoss do
                task.wait(0.003)
                if Character and Character:GetAttribute("MaxStamina") then
                    SetStaminaProperty("Stamina", Character:GetAttribute("MaxStamina"))
                end
            end
        else
            WindUI:Notify({
                Title = "无体力消耗已关闭",
                Content = "体力消耗恢复正常",
                Duration = 3
            })
        end
    end
})
